"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@supabase+auth-js@2.69.1";
exports.ids = ["vendor-chunks/@supabase+auth-js@2.69.1"];
exports.modules = {

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js":
/*!***********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n\nconst AuthAdminApi = _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthAdminApi); //# sourceMappingURL=AuthAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aEFkbWluQXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThDO0FBQzlDLE1BQU1DLGVBQWVELHVEQUFjQTtBQUNuQyxpRUFBZUMsWUFBWUEsRUFBQyxDQUM1Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aEFkbWluQXBpLmpzPzViMTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknO1xuY29uc3QgQXV0aEFkbWluQXBpID0gR29UcnVlQWRtaW5BcGk7XG5leHBvcnQgZGVmYXVsdCBBdXRoQWRtaW5BcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRoQWRtaW5BcGkuanMubWFwIl0sIm5hbWVzIjpbIkdvVHJ1ZUFkbWluQXBpIiwiQXV0aEFkbWluQXBpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/AuthClient.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/AuthClient.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueClient */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n\nconst AuthClient = _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthClient); //# sourceMappingURL=AuthClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUMxQyxNQUFNQyxhQUFhRCxxREFBWUE7QUFDL0IsaUVBQWVDLFVBQVVBLEVBQUMsQ0FDMUIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrYXV0aC1qc0AyLjY5LjEvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL0F1dGhDbGllbnQuanM/Y2Y1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQ2xpZW50IGZyb20gJy4vR29UcnVlQ2xpZW50JztcbmNvbnN0IEF1dGhDbGllbnQgPSBHb1RydWVDbGllbnQ7XG5leHBvcnQgZGVmYXVsdCBBdXRoQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aENsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiR29UcnVlQ2xpZW50IiwiQXV0aENsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/AuthClient.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js":
/*!*************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoTrueAdminApi)\n/* harmony export */ });\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/helpers */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\nvar __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\nclass GoTrueAdminApi {\n    constructor({ url = \"\", headers = {}, fetch }){\n        this.url = url;\n        this.headers = headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n        this.mfa = {\n            listFactors: this._listFactors.bind(this),\n            deleteFactor: this._deleteFactor.bind(this)\n        };\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     * @param scope The logout sope.\n     */ async signOut(jwt, scope = \"global\") {\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/logout?scope=${scope}`, {\n                headers: this.headers,\n                jwt,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param options Additional options to be included when inviting.\n     */ async inviteUserByEmail(email, options = {}) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/invite`, {\n                body: {\n                    email,\n                    data: options.data\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates email links and OTPs to be sent via a custom email provider.\n     * @param email The user's email.\n     * @param options.password User password. For signup only.\n     * @param options.data Optional user metadata. For signup only.\n     * @param options.redirectTo The redirect url which should be appended to the generated link\n     */ async generateLink(params) {\n        try {\n            const { options } = params, rest = __rest(params, [\n                \"options\"\n            ]);\n            const body = Object.assign(Object.assign({}, rest), options);\n            if (\"newEmail\" in rest) {\n                // replace newEmail with new_email in request body\n                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n                delete body[\"newEmail\"];\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/generate_link`, {\n                body: body,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._generateLinkResponse,\n                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        properties: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async createUser(attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/users`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n     */ async listUsers(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const users = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, users), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        users: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async getUserById(uid) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users/${uid}`, {\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async updateUserById(uid, attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"PUT\", `${this.url}/admin/users/${uid}`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * @param id The user id you want to remove.\n     * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n     * Defaults to false for backward compatibility.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async deleteUser(id, shouldSoftDelete = false) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${id}`, {\n                headers: this.headers,\n                body: {\n                    should_soft_delete: shouldSoftDelete\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _listFactors(params) {\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users/${params.userId}/factors`, {\n                headers: this.headers,\n                xform: (factors)=>{\n                    return {\n                        data: {\n                            factors\n                        },\n                        error: null\n                    };\n                }\n            });\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _deleteFactor(params) {\n        try {\n            const data = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n                headers: this.headers\n            });\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n} //# sourceMappingURL=GoTrueAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQWRtaW5BcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQUlBLFNBQVMsU0FBSyxJQUFJLFNBQUksQ0FBQ0EsTUFBTSxJQUFLLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztJQUNoRCxJQUFJQyxJQUFJLENBQUM7SUFDVCxJQUFLLElBQUlDLEtBQUtILEVBQUcsSUFBSUksT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1AsR0FBR0csTUFBTUYsRUFBRU8sT0FBTyxDQUFDTCxLQUFLLEdBQzlFRCxDQUFDLENBQUNDLEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ2YsSUFBSUgsS0FBSyxRQUFRLE9BQU9JLE9BQU9LLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1FBQ3BFLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FDekVSLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDTyxFQUFFLENBQUMsR0FBR1YsQ0FBQyxDQUFDRyxDQUFDLENBQUNPLEVBQUUsQ0FBQztJQUN6QjtJQUNKLE9BQU9SO0FBQ1g7QUFDc0c7QUFDekQ7QUFDRjtBQUM1QixNQUFNaUI7SUFDakJDLFlBQVksRUFBRUMsTUFBTSxFQUFFLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLEtBQUssRUFBRyxDQUFFO1FBQzVDLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsT0FB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LGNBQWNlLE1BQU0sRUFBRTtRQUN4QixJQUFJO1lBQ0EsTUFBTVYsT0FBTyxNQUFNbkIsb0RBQVFBLENBQUMsSUFBSSxDQUFDUSxLQUFLLEVBQUUsVUFBVSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsYUFBYSxFQUFFdUIsT0FBTzZDLE1BQU0sQ0FBQyxTQUFTLEVBQUU3QyxPQUFPMEMsRUFBRSxDQUFDLENBQUMsRUFBRTtnQkFDL0doRSxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUN6QjtZQUNBLE9BQU87Z0JBQUVZO2dCQUFNQyxPQUFPO1lBQUs7UUFDL0IsRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSWpCLHdEQUFXQSxDQUFDaUIsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTtvQkFBTUM7Z0JBQU07WUFDL0I7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2F1dGgtanNAMi42OS4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVBZG1pbkFwaS5qcz9mZDUyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCB7IF9nZW5lcmF0ZUxpbmtSZXNwb25zZSwgX25vUmVzb2x2ZUpzb25SZXNwb25zZSwgX3JlcXVlc3QsIF91c2VyUmVzcG9uc2UsIH0gZnJvbSAnLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9saWIvaGVscGVycyc7XG5pbXBvcnQgeyBpc0F1dGhFcnJvciB9IGZyb20gJy4vbGliL2Vycm9ycyc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVBZG1pbkFwaSB7XG4gICAgY29uc3RydWN0b3IoeyB1cmwgPSAnJywgaGVhZGVycyA9IHt9LCBmZXRjaCwgfSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgICAgIHRoaXMubWZhID0ge1xuICAgICAgICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxldGVGYWN0b3I6IHRoaXMuX2RlbGV0ZUZhY3Rvci5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbG9nZ2VkLWluIHNlc3Npb24uXG4gICAgICogQHBhcmFtIGp3dCBBIHZhbGlkLCBsb2dnZWQtaW4gSldULlxuICAgICAqIEBwYXJhbSBzY29wZSBUaGUgbG9nb3V0IHNvcGUuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk91dChqd3QsIHNjb3BlID0gJ2dsb2JhbCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2xvZ291dD9zY29wZT0ke3Njb3BlfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgand0LFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGludml0ZSBsaW5rIHRvIGFuIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBpbmNsdWRlZCB3aGVuIGludml0aW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGludml0ZVVzZXJCeUVtYWlsKGVtYWlsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9pbnZpdGVgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogeyBlbWFpbCwgZGF0YTogb3B0aW9ucy5kYXRhIH0sXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGVtYWlsIGxpbmtzIGFuZCBPVFBzIHRvIGJlIHNlbnQgdmlhIGEgY3VzdG9tIGVtYWlsIHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSBlbWFpbCBUaGUgdXNlcidzIGVtYWlsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhc3N3b3JkIFVzZXIgcGFzc3dvcmQuIEZvciBzaWdudXAgb25seS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIE9wdGlvbmFsIHVzZXIgbWV0YWRhdGEuIEZvciBzaWdudXAgb25seS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIFRoZSByZWRpcmVjdCB1cmwgd2hpY2ggc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBnZW5lcmF0ZWQgbGlua1xuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlTGluayhwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gcGFyYW1zLCByZXN0ID0gX19yZXN0KHBhcmFtcywgW1wib3B0aW9uc1wiXSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoJ25ld0VtYWlsJyBpbiByZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBuZXdFbWFpbCB3aXRoIG5ld19lbWFpbCBpbiByZXF1ZXN0IGJvZHlcbiAgICAgICAgICAgICAgICBib2R5Lm5ld19lbWFpbCA9IHJlc3QgPT09IG51bGwgfHwgcmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdC5uZXdFbWFpbDtcbiAgICAgICAgICAgICAgICBkZWxldGUgYm9keVsnbmV3RW1haWwnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi9nZW5lcmF0ZV9saW5rYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZXIgQWRtaW4gQVBJXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVXNlcihhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnNgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdXNlcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IHdoaWNoIHN1cHBvcnRzIGBwYWdlYCBhbmQgYHBlclBhZ2VgIGFzIG51bWJlcnMsIHRvIGFsdGVyIHRoZSBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VXNlcnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2luYXRpb24gPSB7IG5leHRQYWdlOiBudWxsLCBsYXN0UGFnZTogMCwgdG90YWw6IDAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiAoX2IgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBwZXJfcGFnZTogKF9kID0gKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBlclBhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2UuZXJyb3I7XG4gICAgICAgICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gKF9lID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtdG90YWwtY291bnQnKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gKF9nID0gKF9mID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2xpbmsnKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnNwbGl0KCcsJykpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFtdO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBwYXJzZUludChsaW5rLnNwbGl0KCc7JylbMF0uc3BsaXQoJz0nKVsxXS5zdWJzdHJpbmcoMCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWwgPSBKU09OLnBhcnNlKGxpbmsuc3BsaXQoJzsnKVsxXS5zcGxpdCgnPScpWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbltgJHtyZWx9UGFnZWBdID0gcGFnZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uLnRvdGFsID0gcGFyc2VJbnQodG90YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1c2VycyksIHBhZ2luYXRpb24pLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcnM6IFtdIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBieSBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1aWQgVGhlIHVzZXIncyB1bmlxdWUgaWRlbnRpZmllclxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VyQnlJZCh1aWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBkYXRhIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVXNlckJ5SWQodWlkLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3VpZH1gLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHVzZXIuIFJlcXVpcmVzIGEgYHNlcnZpY2Vfcm9sZWAga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1c2VyIGlkIHlvdSB3YW50IHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkU29mdERlbGV0ZSBJZiB0cnVlLCB0aGVuIHRoZSB1c2VyIHdpbGwgYmUgc29mdC1kZWxldGVkIGZyb20gdGhlIGF1dGggc2NoZW1hLiBTb2Z0IGRlbGV0aW9uIGFsbG93cyB1c2VyIGlkZW50aWZpY2F0aW9uIGZyb20gdGhlIGhhc2hlZCB1c2VyIElEIGJ1dCBpcyBub3QgcmV2ZXJzaWJsZS5cbiAgICAgKiBEZWZhdWx0cyB0byBmYWxzZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlVXNlcihpZCwgc2hvdWxkU29mdERlbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke2lkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRfc29mdF9kZWxldGU6IHNob3VsZFNvZnREZWxldGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2xpc3RGYWN0b3JzKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoZmFjdG9ycykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGZhY3RvcnMgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZGVsZXRlRmFjdG9yKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtwYXJhbXMudXNlcklkfS9mYWN0b3JzLyR7cGFyYW1zLmlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R29UcnVlQWRtaW5BcGkuanMubWFwIl0sIm5hbWVzIjpbIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2dlbmVyYXRlTGlua1Jlc3BvbnNlIiwiX25vUmVzb2x2ZUpzb25SZXNwb25zZSIsIl9yZXF1ZXN0IiwiX3VzZXJSZXNwb25zZSIsInJlc29sdmVGZXRjaCIsImlzQXV0aEVycm9yIiwiR29UcnVlQWRtaW5BcGkiLCJjb25zdHJ1Y3RvciIsInVybCIsImhlYWRlcnMiLCJmZXRjaCIsIm1mYSIsImxpc3RGYWN0b3JzIiwiX2xpc3RGYWN0b3JzIiwiYmluZCIsImRlbGV0ZUZhY3RvciIsIl9kZWxldGVGYWN0b3IiLCJzaWduT3V0Iiwiand0Iiwic2NvcGUiLCJub1Jlc29sdmVKc29uIiwiZGF0YSIsImVycm9yIiwiaW52aXRlVXNlckJ5RW1haWwiLCJlbWFpbCIsIm9wdGlvbnMiLCJib2R5IiwicmVkaXJlY3RUbyIsInhmb3JtIiwidXNlciIsImdlbmVyYXRlTGluayIsInBhcmFtcyIsInJlc3QiLCJhc3NpZ24iLCJuZXdfZW1haWwiLCJuZXdFbWFpbCIsInByb3BlcnRpZXMiLCJjcmVhdGVVc2VyIiwiYXR0cmlidXRlcyIsImxpc3RVc2VycyIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwicGFnaW5hdGlvbiIsIm5leHRQYWdlIiwibGFzdFBhZ2UiLCJ0b3RhbCIsInJlc3BvbnNlIiwicXVlcnkiLCJwYWdlIiwidG9TdHJpbmciLCJwZXJfcGFnZSIsInBlclBhZ2UiLCJ1c2VycyIsImpzb24iLCJnZXQiLCJsaW5rcyIsInNwbGl0IiwiZm9yRWFjaCIsImxpbmsiLCJwYXJzZUludCIsInN1YnN0cmluZyIsInJlbCIsIkpTT04iLCJwYXJzZSIsImdldFVzZXJCeUlkIiwidWlkIiwidXBkYXRlVXNlckJ5SWQiLCJkZWxldGVVc2VyIiwiaWQiLCJzaG91bGRTb2Z0RGVsZXRlIiwic2hvdWxkX3NvZnRfZGVsZXRlIiwidXNlcklkIiwiZmFjdG9ycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueClient.js":
/*!***********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueClient.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoTrueClient)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/fetch */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/helpers */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/local-storage */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\");\n/* harmony import */ var _lib_polyfills__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/polyfills */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\");\n/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/version */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/locks */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n/* harmony import */ var _lib_base64url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/base64url */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n\n\n\n\n\n\n\n\n\n\n(0,_lib_polyfills__WEBPACK_IMPORTED_MODULE_6__.polyfillGlobalThis)(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.GOTRUE_URL,\n    storageKey: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HEADERS,\n    flowType: \"implicit\",\n    debug: false,\n    hasCustomAuthorizationHeader: false\n};\nasync function lockNoOp(name, acquireTimeout, fn) {\n    return await fn();\n}\nclass GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     */ constructor(options){\n        var _a, _b;\n        this.memoryStorage = null;\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the the auth state is known and it's save to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */ this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        this.hasCustomAuthorizationHeader = false;\n        this.suppressGetSessionWarning = false;\n        this.lockAcquired = false;\n        this.pendingInLock = [];\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */ this.broadcastChannel = null;\n        this.logger = console.log;\n        this.instanceID = GoTrueClient.nextInstanceID;\n        GoTrueClient.nextInstanceID += 1;\n        if (this.instanceID > 0 && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n            console.warn(\"Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.\");\n        }\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.logDebugMessages = !!settings.debug;\n        if (typeof settings.debug === \"function\") {\n            this.logger = settings.debug;\n        }\n        this.persistSession = settings.persistSession;\n        this.storageKey = settings.storageKey;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.admin = new _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveFetch)(settings.fetch);\n        this.lock = settings.lock || lockNoOp;\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.flowType = settings.flowType;\n        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;\n        if (settings.lock) {\n            this.lock = settings.lock;\n        } else if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.locks)) {\n            this.lock = _lib_locks__WEBPACK_IMPORTED_MODULE_8__.navigatorLock;\n        } else {\n            this.lock = lockNoOp;\n        }\n        this.jwks = {\n            keys: []\n        };\n        this.jwks_cached_at = Number.MIN_SAFE_INTEGER;\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n        };\n        if (this.persistSession) {\n            if (settings.storage) {\n                this.storage = settings.storage;\n            } else {\n                if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.supportsLocalStorage)()) {\n                    this.storage = _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.localStorageAdapter;\n                } else {\n                    this.memoryStorage = {};\n                    this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n                }\n            }\n        } else {\n            this.memoryStorage = {};\n            this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n        }\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            try {\n                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            } catch (e) {\n                console.error(\"Failed to create a new BroadcastChannel, multi-tab state changes will not be available\", e);\n            }\n            (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener(\"message\", async (event)=>{\n                this._debug(\"received broadcast notification from other tab or client\", event);\n                await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n            });\n        }\n        this.initialize();\n    }\n    _debug(...args) {\n        if (this.logDebugMessages) {\n            this.logger(`GoTrueClient@${this.instanceID} (${_lib_version__WEBPACK_IMPORTED_MODULE_7__.version}) ${new Date().toISOString()}`, ...args);\n        }\n        return this;\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */ async initialize() {\n        if (this.initializePromise) {\n            return await this.initializePromise;\n        }\n        this.initializePromise = (async ()=>{\n            return await this._acquireLock(-1, async ()=>{\n                return await this._initialize();\n            });\n        })();\n        return await this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */ async _initialize() {\n        var _a;\n        try {\n            const params = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.parseParametersFromURL)(window.location.href);\n            let callbackUrlType = \"none\";\n            if (this._isImplicitGrantCallback(params)) {\n                callbackUrlType = \"implicit\";\n            } else if (await this._isPKCECallback(params)) {\n                callbackUrlType = \"pkce\";\n            }\n            /**\n             * Attempt to get the session from the URL only if these conditions are fulfilled\n             *\n             * Note: If the URL isn't one of the callback url types (implicit or pkce),\n             * then there could be an existing session so we don't want to prematurely remove it\n             */ if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== \"none\") {\n                const { data, error } = await this._getSessionFromURL(params, callbackUrlType);\n                if (error) {\n                    this._debug(\"#_initialize()\", \"error detecting session from URL\", error);\n                    if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError)(error)) {\n                        const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;\n                        if (errorCode === \"identity_already_exists\" || errorCode === \"identity_not_found\" || errorCode === \"single_identity_not_deletable\") {\n                            return {\n                                error\n                            };\n                        }\n                    }\n                    // failed login attempt via url,\n                    // remove old session as in verifyOtp, signUp and signInWith*\n                    await this._removeSession();\n                    return {\n                        error\n                    };\n                }\n                const { session, redirectType } = data;\n                this._debug(\"#_initialize()\", \"detected session in URL\", session, \"redirect type\", redirectType);\n                await this._saveSession(session);\n                setTimeout(async ()=>{\n                    if (redirectType === \"recovery\") {\n                        await this._notifyAllSubscribers(\"PASSWORD_RECOVERY\", session);\n                    } else {\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n                    }\n                }, 0);\n                return {\n                    error: null\n                };\n            }\n            // no login attempt via callback url try to recover session from storage\n            await this._recoverAndRefresh();\n            return {\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    error\n                };\n            }\n            return {\n                error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(\"Unexpected error during initialization\", error)\n            };\n        } finally{\n            await this._handleVisibilityChange();\n            this._debug(\"#_initialize()\", \"end\");\n        }\n    }\n    /**\n     * Creates a new anonymous user.\n     *\n     * @returns A session where the is_anonymous claim in the access token JWT set to true\n     */ async signInAnonymously(credentials) {\n        var _a, _b, _c;\n        try {\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                headers: this.headers,\n                body: {\n                    data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                        captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error || !data) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                };\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */ async signUp(credentials) {\n        var _a, _b, _c;\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: {\n                        email,\n                        password,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                        channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : \"sms\",\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error || !data) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                };\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */ async signInWithPassword(credentials) {\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            } else if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data: Object.assign({\n                    user: data.user,\n                    session: data.session\n                }, data.weak_password ? {\n                    weakPassword: data.weak_password\n                } : null),\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     * This method supports the PKCE flow.\n     */ async signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return await this._handleProviderSignIn(credentials.provider, {\n            redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n            skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n        });\n    }\n    /**\n     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n     */ async exchangeCodeForSession(authCode) {\n        await this.initializePromise;\n        return this._acquireLock(-1, async ()=>{\n            return this._exchangeCodeForSession(authCode);\n        });\n    }\n    async _exchangeCodeForSession(authCode) {\n        const storageItem = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : \"\").split(\"/\");\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=pkce`, {\n                headers: this.headers,\n                body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data: Object.assign(Object.assign({}, data), {\n                    redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null\n                }),\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Allows signing in with an OIDC ID token. The authentication provider used\n     * should be enabled and configured.\n     */ async signInWithIdToken(credentials) {\n        try {\n            const { options, provider, token, access_token, nonce } = credentials;\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=id_token`, {\n                headers: this.headers,\n                body: {\n                    provider,\n                    id_token: token,\n                    access_token,\n                    nonce,\n                    gotrue_meta_security: {\n                        captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            } else if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     * This method supports PKCE when an email is passed.\n     */ async signInWithOtp(credentials) {\n        var _a, _b, _c, _d, _e;\n        try {\n            if (\"email\" in credentials) {\n                const { email, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            if (\"phone\" in credentials) {\n                const { phone, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                        create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : \"sms\"\n                    }\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                };\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number.\");\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.\n     */ async verifyOtp(params) {\n        var _a, _b;\n        try {\n            let redirectTo = undefined;\n            let captchaToken = undefined;\n            if (\"options\" in params) {\n                redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;\n                captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/verify`, {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                        captcha_token: captchaToken\n                    }\n                }),\n                redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data) {\n                throw new Error(\"An error occurred on token verification.\");\n            }\n            const session = data.session;\n            const user = data.user;\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(params.type == \"recovery\" ? \"PASSWORD_RECOVERY\" : \"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */ async signInWithSSO(params) {\n        var _a, _b, _c;\n        try {\n            let codeChallenge = null;\n            let codeChallengeMethod = null;\n            if (this.flowType === \"pkce\") {\n                ;\n                [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/sso`, {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, \"providerId\" in params ? {\n                    provider_id: params.providerId\n                } : null), \"domain\" in params ? {\n                    domain: params.domain\n                } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: params.options.captchaToken\n                    }\n                } : null), {\n                    skip_http_redirect: true,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod\n                }),\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._ssoResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends a reauthentication OTP to the user's email or phone number.\n     * Requires the user to be signed-in.\n     */ async reauthenticate() {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._reauthenticate();\n        });\n    }\n    async _reauthenticate() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) throw sessionError;\n                if (!session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/reauthenticate`, {\n                    headers: this.headers,\n                    jwt: session.access_token\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n     */ async resend(credentials) {\n        try {\n            const endpoint = `${this.url}/resend`;\n            if (\"email\" in credentials) {\n                const { email, type, options } = credentials;\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            } else if (\"phone\" in credentials) {\n                const { phone, type, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    }\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                };\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a type\");\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     *\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     *\n     * **IMPORTANT:** This method loads values directly from the storage attached\n     * to the client. If that storage is based on request cookies for example,\n     * the values in it may not be authentic and therefore it's strongly advised\n     * against using this method and its results in such circumstances. A warning\n     * will be emitted if this is detected. Use {@link #getUser()} instead.\n     */ async getSession() {\n        await this.initializePromise;\n        const result = await this._acquireLock(-1, async ()=>{\n            return this._useSession(async (result)=>{\n                return result;\n            });\n        });\n        return result;\n    }\n    /**\n     * Acquires a global lock based on the storage key.\n     */ async _acquireLock(acquireTimeout, fn) {\n        this._debug(\"#_acquireLock\", \"begin\", acquireTimeout);\n        try {\n            if (this.lockAcquired) {\n                const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();\n                const result = (async ()=>{\n                    await last;\n                    return await fn();\n                })();\n                this.pendingInLock.push((async ()=>{\n                    try {\n                        await result;\n                    } catch (e) {\n                    // we just care if it finished\n                    }\n                })());\n                return result;\n            }\n            return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async ()=>{\n                this._debug(\"#_acquireLock\", \"lock acquired for storage key\", this.storageKey);\n                try {\n                    this.lockAcquired = true;\n                    const result = fn();\n                    this.pendingInLock.push((async ()=>{\n                        try {\n                            await result;\n                        } catch (e) {\n                        // we just care if it finished\n                        }\n                    })());\n                    await result;\n                    // keep draining the queue until there's nothing to wait on\n                    while(this.pendingInLock.length){\n                        const waitOn = [\n                            ...this.pendingInLock\n                        ];\n                        await Promise.all(waitOn);\n                        this.pendingInLock.splice(0, waitOn.length);\n                    }\n                    return await result;\n                } finally{\n                    this._debug(\"#_acquireLock\", \"lock released for storage key\", this.storageKey);\n                    this.lockAcquired = false;\n                }\n            });\n        } finally{\n            this._debug(\"#_acquireLock\", \"end\");\n        }\n    }\n    /**\n     * Use instead of {@link #getSession} inside the library. It is\n     * semantically usually what you want, as getting a session involves some\n     * processing afterwards that requires only one client operating on the\n     * session at once across multiple tabs or processes.\n     */ async _useSession(fn) {\n        this._debug(\"#_useSession\", \"begin\");\n        try {\n            // the use of __loadSession here is the only correct use of the function!\n            const result = await this.__loadSession();\n            return await fn(result);\n        } finally{\n            this._debug(\"#_useSession\", \"end\");\n        }\n    }\n    /**\n     * NEVER USE DIRECTLY!\n     *\n     * Always use {@link #_useSession}.\n     */ async __loadSession() {\n        this._debug(\"#__loadSession()\", \"begin\");\n        if (!this.lockAcquired) {\n            this._debug(\"#__loadSession()\", \"used outside of an acquired lock!\", new Error().stack);\n        }\n        try {\n            let currentSession = null;\n            const maybeSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug(\"#getSession()\", \"session from storage\", maybeSession);\n            if (maybeSession !== null) {\n                if (this._isValidSession(maybeSession)) {\n                    currentSession = maybeSession;\n                } else {\n                    this._debug(\"#getSession()\", \"session from storage is not valid\");\n                    await this._removeSession();\n                }\n            }\n            if (!currentSession) {\n                return {\n                    data: {\n                        session: null\n                    },\n                    error: null\n                };\n            }\n            // A session is considered expired before the access token _actually_\n            // expires. When the autoRefreshToken option is off (or when the tab is\n            // in the background), very eager users of getSession() -- like\n            // realtime-js -- might send a valid JWT which will expire by the time it\n            // reaches the server.\n            const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS : false;\n            this._debug(\"#__loadSession()\", `session has${hasExpired ? \"\" : \" not\"} expired`, \"expires_at\", currentSession.expires_at);\n            if (!hasExpired) {\n                if (this.storage.isServer) {\n                    let suppressWarning = this.suppressGetSessionWarning;\n                    const proxySession = new Proxy(currentSession, {\n                        get: (target, prop, receiver)=>{\n                            if (!suppressWarning && prop === \"user\") {\n                                // only show warning when the user object is being accessed from the server\n                                console.warn(\"Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.\");\n                                suppressWarning = true; // keeps this proxy instance from logging additional warnings\n                                this.suppressGetSessionWarning = true; // keeps this client's future proxy instances from warning\n                            }\n                            return Reflect.get(target, prop, receiver);\n                        }\n                    });\n                    currentSession = proxySession;\n                }\n                return {\n                    data: {\n                        session: currentSession\n                    },\n                    error: null\n                };\n            }\n            const { session, error } = await this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return {\n                    data: {\n                        session: null\n                    },\n                    error\n                };\n            }\n            return {\n                data: {\n                    session\n                },\n                error: null\n            };\n        } finally{\n            this._debug(\"#__loadSession()\", \"end\");\n        }\n    }\n    /**\n     * Gets the current user details if there is an existing session. This method\n     * performs a network request to the Supabase Auth server, so the returned\n     * value is authentic and can be used to base authorization rules on.\n     *\n     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.\n     */ async getUser(jwt) {\n        if (jwt) {\n            return await this._getUser(jwt);\n        }\n        await this.initializePromise;\n        const result = await this._acquireLock(-1, async ()=>{\n            return await this._getUser();\n        });\n        return result;\n    }\n    async _getUser(jwt) {\n        try {\n            if (jwt) {\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            }\n            return await this._useSession(async (result)=>{\n                var _a, _b, _c;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                // returns an error if there is no access_token or custom authorization header\n                if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {\n                    return {\n                        data: {\n                            user: null\n                        },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error)) {\n                    // JWT contains a `session_id` which does not correspond to an active\n                    // session in the database, indicating the user is signed out.\n                    await this._removeSession();\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                }\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates user data for a logged in user.\n     */ async updateUser(attributes, options = {}) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._updateUser(attributes, options);\n        });\n    }\n    async _updateUser(attributes, options = {}) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\" && attributes.email != null) {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { data, error: userError } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"PUT\", `${this.url}/user`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: Object.assign(Object.assign({}, attributes), {\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    }),\n                    jwt: session.access_token,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n                if (userError) throw userError;\n                session.user = data.user;\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"USER_UPDATED\", session);\n                return {\n                    data: {\n                        user: session.user\n                    },\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */ async setSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._setSession(currentSession);\n        });\n    }\n    async _setSession(currentSession) {\n        try {\n            if (!currentSession.access_token || !currentSession.refresh_token) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            }\n            const timeNow = Date.now() / 1000;\n            let expiresAt = timeNow;\n            let hasExpired = true;\n            let session = null;\n            const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(currentSession.access_token);\n            if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n            }\n            if (hasExpired) {\n                const { session: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    };\n                }\n                if (!refreshedSession) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    };\n                }\n                session = refreshedSession;\n            } else {\n                const { data, error } = await this._getUser(currentSession.access_token);\n                if (error) {\n                    throw error;\n                }\n                session = {\n                    access_token: currentSession.access_token,\n                    refresh_token: currentSession.refresh_token,\n                    user: data.user,\n                    token_type: \"bearer\",\n                    expires_in: expiresAt - timeNow,\n                    expires_at: expiresAt\n                };\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user: session.user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */ async refreshSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._refreshSession(currentSession);\n        });\n    }\n    async _refreshSession(currentSession) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                if (!currentSession) {\n                    const { data, error } = result;\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const { session, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    };\n                }\n                if (!session) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    };\n                }\n                return {\n                    data: {\n                        user: session.user,\n                        session\n                    },\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets the session data from a URL string\n     */ async _getSessionFromURL(params, callbackUrlType) {\n        try {\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No browser detected.\");\n            // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.\n            if (params.error || params.error_description || params.error_code) {\n                // The error class returned implies that the redirect is from an implicit grant flow\n                // but it could also be from a redirect error from a PKCE flow.\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(params.error_description || \"Error in URL with unspecified error_description\", {\n                    error: params.error || \"unspecified_error\",\n                    code: params.error_code || \"unspecified_code\"\n                });\n            }\n            // Checks for mismatches between the flowType initialised in the client and the URL parameters\n            switch(callbackUrlType){\n                case \"implicit\":\n                    if (this.flowType === \"pkce\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"Not a valid PKCE flow url.\");\n                    }\n                    break;\n                case \"pkce\":\n                    if (this.flowType === \"implicit\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"Not a valid implicit grant flow url.\");\n                    }\n                    break;\n                default:\n            }\n            // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange\n            if (callbackUrlType === \"pkce\") {\n                this._debug(\"#_initialize()\", \"begin\", \"is PKCE flow\", true);\n                if (!params.code) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"No code detected.\");\n                const { data, error } = await this._exchangeCodeForSession(params.code);\n                if (error) throw error;\n                const url = new URL(window.location.href);\n                url.searchParams.delete(\"code\");\n                window.history.replaceState(window.history.state, \"\", url.toString());\n                return {\n                    data: {\n                        session: data.session,\n                        redirectType: null\n                    },\n                    error: null\n                };\n            }\n            const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;\n            if (!access_token || !expires_in || !refresh_token || !token_type) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No session defined in URL\");\n            }\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = parseInt(expires_in);\n            let expiresAt = timeNow + expiresIn;\n            if (expires_at) {\n                expiresAt = parseInt(expires_at);\n            }\n            const actuallyExpiresIn = expiresAt - timeNow;\n            if (actuallyExpiresIn * 1000 <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS) {\n                console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);\n            }\n            const issuedAt = expiresAt - expiresIn;\n            if (timeNow - issuedAt >= 120) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale\", issuedAt, expiresAt, timeNow);\n            } else if (timeNow - issuedAt < 0) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew\", issuedAt, expiresAt, timeNow);\n            }\n            const { data, error } = await this._getUser(access_token);\n            if (error) throw error;\n            const session = {\n                provider_token,\n                provider_refresh_token,\n                access_token,\n                expires_in: expiresIn,\n                expires_at: expiresAt,\n                refresh_token,\n                token_type,\n                user: data.user\n            };\n            // Remove tokens from URL\n            window.location.hash = \"\";\n            this._debug(\"#_getSessionFromURL()\", \"clearing window.location.hash\");\n            return {\n                data: {\n                    session,\n                    redirectType: params.type\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */ _isImplicitGrantCallback(params) {\n        return Boolean(params.access_token || params.error_description);\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */ async _isPKCECallback(params) {\n        const currentStorageContent = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        return !!(params.code && currentStorageContent);\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     *\n     * If using `others` scope, no `SIGNED_OUT` event is fired!\n     */ async signOut(options = {\n        scope: \"global\"\n    }) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._signOut(options);\n        });\n    }\n    async _signOut({ scope } = {\n        scope: \"global\"\n    }) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            const { data, error: sessionError } = result;\n            if (sessionError) {\n                return {\n                    error: sessionError\n                };\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = await this.admin.signOut(accessToken, scope);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError)(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {\n                        return {\n                            error\n                        };\n                    }\n                }\n            }\n            if (scope !== \"others\") {\n                await this._removeSession();\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            }\n            return {\n                error: null\n            };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */ onAuthStateChange(callback) {\n        const id = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.uuid)();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: ()=>{\n                this._debug(\"#unsubscribe()\", \"state change callback with id removed\", id);\n                this.stateChangeEmitters.delete(id);\n            }\n        };\n        this._debug(\"#onAuthStateChange()\", \"registered callback with id\", id);\n        this.stateChangeEmitters.set(id, subscription);\n        (async ()=>{\n            await this.initializePromise;\n            await this._acquireLock(-1, async ()=>{\n                this._emitInitialSession(id);\n            });\n        })();\n        return {\n            data: {\n                subscription\n            }\n        };\n    }\n    async _emitInitialSession(id) {\n        return await this._useSession(async (result)=>{\n            var _a, _b;\n            try {\n                const { data: { session }, error } = result;\n                if (error) throw error;\n                await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback(\"INITIAL_SESSION\", session));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"session\", session);\n            } catch (err) {\n                await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback(\"INITIAL_SESSION\", null));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"error\", err);\n                console.error(err);\n            }\n        });\n    }\n    /**\n     * Sends a password reset request to an email address. This method supports the PKCE flow.\n     *\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */ async resetPasswordForEmail(email, options = {}) {\n        let codeChallenge = null;\n        let codeChallengeMethod = null;\n        if (this.flowType === \"pkce\") {\n            ;\n            [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery\n            );\n        }\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/recover`, {\n                body: {\n                    email,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets all the identities linked to a user.\n     */ async getUserIdentities() {\n        var _a;\n        try {\n            const { data, error } = await this.getUser();\n            if (error) throw error;\n            return {\n                data: {\n                    identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Links an oauth identity to an existing user.\n     * This method supports the PKCE flow.\n     */ async linkIdentity(credentials) {\n        var _a;\n        try {\n            const { data, error } = await this._useSession(async (result)=>{\n                var _a, _b, _c, _d, _e;\n                const { data, error } = result;\n                if (error) throw error;\n                const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {\n                    redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                    scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                    queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                    skipBrowserRedirect: true\n                });\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", url, {\n                    headers: this.headers,\n                    jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined\n                });\n            });\n            if (error) throw error;\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {\n                window.location.assign(data === null || data === void 0 ? void 0 : data.url);\n            }\n            return {\n                data: {\n                    provider: credentials.provider,\n                    url: data === null || data === void 0 ? void 0 : data.url\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        provider: credentials.provider,\n                        url: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n     */ async unlinkIdentity(identity) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/user/identities/${identity.identity_id}`, {\n                    headers: this.headers,\n                    jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */ async _refreshAccessToken(refreshToken) {\n        const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            const startedAt = Date.now();\n            // will attempt to refresh the token with exponential backoff\n            return await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.retryable)(async (attempt)=>{\n                if (attempt > 0) {\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...\n                }\n                this._debug(debugName, \"refreshing attempt\", attempt);\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=refresh_token`, {\n                    body: {\n                        refresh_token: refreshToken\n                    },\n                    headers: this.headers,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            }, (attempt, error)=>{\n                const nextBackOffInterval = 200 * Math.pow(2, attempt);\n                return error && (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error) && // retryable only if the request can be sent before the backoff overflows the tick duration\n                Date.now() + nextBackOffInterval - startedAt < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS;\n            });\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === \"object\" && maybeSession !== null && \"access_token\" in maybeSession && \"refresh_token\" in maybeSession && \"expires_at\" in maybeSession;\n        return isValidSession;\n    }\n    async _handleProviderSignIn(provider, options) {\n        const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams\n        });\n        this._debug(\"#_handleProviderSignIn()\", \"provider\", provider, \"options\", options, \"url\", url);\n        // try to open on the browser\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !options.skipBrowserRedirect) {\n            window.location.assign(url);\n        }\n        return {\n            data: {\n                provider,\n                url\n            },\n            error: null\n        };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes the token\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */ async _recoverAndRefresh() {\n        var _a;\n        const debugName = \"#_recoverAndRefresh()\";\n        this._debug(debugName, \"begin\");\n        try {\n            const currentSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug(debugName, \"session from storage\", currentSession);\n            if (!this._isValidSession(currentSession)) {\n                this._debug(debugName, \"session is not valid\");\n                if (currentSession !== null) {\n                    await this._removeSession();\n                }\n                return;\n            }\n            const expiresWithMargin = ((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS;\n            this._debug(debugName, `session has${expiresWithMargin ? \"\" : \" not\"} expired with margin of ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS}s`);\n            if (expiresWithMargin) {\n                if (this.autoRefreshToken && currentSession.refresh_token) {\n                    const { error } = await this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        console.error(error);\n                        if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                            this._debug(debugName, \"refresh failed with a non-retryable error, removing the session\", error);\n                            await this._removeSession();\n                        }\n                    }\n                }\n            } else {\n                // no need to persist currentSession again, as we just loaded it from\n                // local storage; persisting it again may overwrite a value saved by\n                // another client with access to the same local storage\n                await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n            }\n        } catch (err) {\n            this._debug(debugName, \"error\", err);\n            console.error(err);\n            return;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _callRefreshToken(refreshToken) {\n        var _a, _b;\n        if (!refreshToken) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n        }\n        // refreshing is already in progress\n        if (this.refreshingDeferred) {\n            return this.refreshingDeferred.promise;\n        }\n        const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            this.refreshingDeferred = new _lib_helpers__WEBPACK_IMPORTED_MODULE_4__.Deferred();\n            const { data, error } = await this._refreshAccessToken(refreshToken);\n            if (error) throw error;\n            if (!data.session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            await this._saveSession(data.session);\n            await this._notifyAllSubscribers(\"TOKEN_REFRESHED\", data.session);\n            const result = {\n                session: data.session,\n                error: null\n            };\n            this.refreshingDeferred.resolve(result);\n            return result;\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                const result = {\n                    session: null,\n                    error\n                };\n                if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                    await this._removeSession();\n                }\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                return result;\n            }\n            (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n            throw error;\n        } finally{\n            this.refreshingDeferred = null;\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _notifyAllSubscribers(event, session, broadcast = true) {\n        const debugName = `#_notifyAllSubscribers(${event})`;\n        this._debug(debugName, \"begin\", session, `broadcast = ${broadcast}`);\n        try {\n            if (this.broadcastChannel && broadcast) {\n                this.broadcastChannel.postMessage({\n                    event,\n                    session\n                });\n            }\n            const errors = [];\n            const promises = Array.from(this.stateChangeEmitters.values()).map(async (x)=>{\n                try {\n                    await x.callback(event, session);\n                } catch (e) {\n                    errors.push(e);\n                }\n            });\n            await Promise.all(promises);\n            if (errors.length > 0) {\n                for(let i = 0; i < errors.length; i += 1){\n                    console.error(errors[i]);\n                }\n                throw errors[0];\n            }\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */ async _saveSession(session) {\n        this._debug(\"#_saveSession()\", session);\n        // _saveSession is always called whenever a new session has been acquired\n        // so we can safely suppress the warning returned by future getSession calls\n        this.suppressGetSessionWarning = true;\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, session);\n    }\n    async _removeSession() {\n        this._debug(\"#_removeSession()\");\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey);\n        await this._notifyAllSubscribers(\"SIGNED_OUT\", null);\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */ _removeVisibilityChangedCallback() {\n        this._debug(\"#_removeVisibilityChangedCallback()\");\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener(\"visibilitychange\", callback);\n            }\n        } catch (e) {\n            console.error(\"removing visibilitychange callback failed\", e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */ async _startAutoRefresh() {\n        await this._stopAutoRefresh();\n        this._debug(\"#_startAutoRefresh()\");\n        const ticker = setInterval(()=>this._autoRefreshTokenTick(), _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n        this.autoRefreshTicker = ticker;\n        if (ticker && typeof ticker === \"object\" && typeof ticker.unref === \"function\") {\n            // ticker is a NodeJS Timeout object that has an `unref` method\n            // https://nodejs.org/api/timers.html#timeoutunref\n            // When auto refresh is used in NodeJS (like for testing) the\n            // `setInterval` is preventing the process from being marked as\n            // finished and tests run endlessly. This can be prevented by calling\n            // `unref()` on the returned object.\n            ticker.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // similar like for NodeJS, but with the Deno API\n            // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(ticker);\n        }\n        // run the tick immediately, but in the next pass of the event loop so that\n        // #_initialize can be allowed to complete without recursively waiting on\n        // itself\n        setTimeout(async ()=>{\n            await this.initializePromise;\n            await this._autoRefreshTokenTick();\n        }, 0);\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */ async _stopAutoRefresh() {\n        this._debug(\"#_stopAutoRefresh()\");\n        const ticker = this.autoRefreshTicker;\n        this.autoRefreshTicker = null;\n        if (ticker) {\n            clearInterval(ticker);\n        }\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desirable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */ async startAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._startAutoRefresh();\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */ async stopAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._stopAutoRefresh();\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */ async _autoRefreshTokenTick() {\n        this._debug(\"#_autoRefreshTokenTick()\", \"begin\");\n        try {\n            await this._acquireLock(0, async ()=>{\n                try {\n                    const now = Date.now();\n                    try {\n                        return await this._useSession(async (result)=>{\n                            const { data: { session } } = result;\n                            if (!session || !session.refresh_token || !session.expires_at) {\n                                this._debug(\"#_autoRefreshTokenTick()\", \"no session\");\n                                return;\n                            }\n                            // session will expire in this many ticks (or has already expired if <= 0)\n                            const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n                            this._debug(\"#_autoRefreshTokenTick()\", `access token expires in ${expiresInTicks} ticks, a tick lasts ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD} ticks`);\n                            if (expiresInTicks <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD) {\n                                await this._callRefreshToken(session.refresh_token);\n                            }\n                        });\n                    } catch (e) {\n                        console.error(\"Auto refresh tick failed with error. This is likely a transient error.\", e);\n                    }\n                } finally{\n                    this._debug(\"#_autoRefreshTokenTick()\", \"end\");\n                }\n            });\n        } catch (e) {\n            if (e.isAcquireTimeout || e instanceof _lib_locks__WEBPACK_IMPORTED_MODULE_8__.LockAcquireTimeoutError) {\n                this._debug(\"auto refresh token tick lock not available\");\n            } else {\n                throw e;\n            }\n        }\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */ async _handleVisibilityChange() {\n        this._debug(\"#_handleVisibilityChange()\");\n        if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n            }\n            return false;\n        }\n        try {\n            this.visibilityChangedCallback = async ()=>await this._onVisibilityChanged(false);\n            window === null || window === void 0 ? void 0 : window.addEventListener(\"visibilitychange\", this.visibilityChangedCallback);\n            // now immediately call the visbility changed callback to setup with the\n            // current visbility state\n            await this._onVisibilityChanged(true); // initial call\n        } catch (error) {\n            console.error(\"_handleVisibilityChange\", error);\n        }\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */ async _onVisibilityChanged(calledFromInitialize) {\n        const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;\n        this._debug(methodName, \"visibilityState\", document.visibilityState);\n        if (document.visibilityState === \"visible\") {\n            if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n            }\n            if (!calledFromInitialize) {\n                // called when the visibility has changed, i.e. the browser\n                // transitioned from hidden -> visible so we need to see if the session\n                // should be recovered immediately... but to do that we need to acquire\n                // the lock first asynchronously\n                await this.initializePromise;\n                await this._acquireLock(-1, async ()=>{\n                    if (document.visibilityState !== \"visible\") {\n                        this._debug(methodName, \"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting\");\n                        // visibility has changed while waiting for the lock, abort\n                        return;\n                    }\n                    // recover the session\n                    await this._recoverAndRefresh();\n                });\n            }\n        } else if (document.visibilityState === \"hidden\") {\n            if (this.autoRefreshToken) {\n                this._stopAutoRefresh();\n            }\n        }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */ async _getUrlForProvider(url, provider, options) {\n        const urlParams = [\n            `provider=${encodeURIComponent(provider)}`\n        ];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (this.flowType === \"pkce\") {\n            const [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            const flowParams = new URLSearchParams({\n                code_challenge: `${encodeURIComponent(codeChallenge)}`,\n                code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`\n            });\n            urlParams.push(flowParams.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {\n            urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);\n        }\n        return `${url}?${urlParams.join(\"&\")}`;\n    }\n    async _unenroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _enroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                const body = Object.assign({\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType\n                }, params.factorType === \"phone\" ? {\n                    phone: params.phone\n                } : {\n                    issuer: params.issuer\n                });\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors`, {\n                    body,\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n                if (error) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                if (params.factorType === \"totp\" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return {\n                    data,\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * {@see GoTrueMFAApi#verify}\n     */ async _verify(params) {\n        return this._acquireLock(-1, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return {\n                            data: null,\n                            error: sessionError\n                        };\n                    }\n                    const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/verify`, {\n                        body: {\n                            code: params.code,\n                            challenge_id: params.challengeId\n                        },\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (error) {\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                    await this._saveSession(Object.assign({\n                        expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                    }, data));\n                    await this._notifyAllSubscribers(\"MFA_CHALLENGE_VERIFIED\", data);\n                    return {\n                        data,\n                        error\n                    };\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challenge}\n     */ async _challenge(params) {\n        return this._acquireLock(-1, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return {\n                            data: null,\n                            error: sessionError\n                        };\n                    }\n                    return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/challenge`, {\n                        body: {\n                            channel: params.channel\n                        },\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */ async _challengeAndVerify(params) {\n        // both _challenge and _verify independently acquire the lock, so no need\n        // to acquire it here\n        const { data: challengeData, error: challengeError } = await this._challenge({\n            factorId: params.factorId\n        });\n        if (challengeError) {\n            return {\n                data: null,\n                error: challengeError\n            };\n        }\n        return await this._verify({\n            factorId: params.factorId,\n            challengeId: challengeData.id,\n            code: params.code\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */ async _listFactors() {\n        // use #getUser instead of #_getUser as the former acquires a lock\n        const { data: { user }, error: userError } = await this.getUser();\n        if (userError) {\n            return {\n                data: null,\n                error: userError\n            };\n        }\n        const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n        const totp = factors.filter((factor)=>factor.factor_type === \"totp\" && factor.status === \"verified\");\n        const phone = factors.filter((factor)=>factor.factor_type === \"phone\" && factor.status === \"verified\");\n        return {\n            data: {\n                all: factors,\n                totp,\n                phone\n            },\n            error: null\n        };\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */ async _getAuthenticatorAssuranceLevel() {\n        return this._acquireLock(-1, async ()=>{\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                if (!session) {\n                    return {\n                        data: {\n                            currentLevel: null,\n                            nextLevel: null,\n                            currentAuthenticationMethods: []\n                        },\n                        error: null\n                    };\n                }\n                const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(session.access_token);\n                let currentLevel = null;\n                if (payload.aal) {\n                    currentLevel = payload.aal;\n                }\n                let nextLevel = currentLevel;\n                const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor)=>factor.status === \"verified\")) !== null && _b !== void 0 ? _b : [];\n                if (verifiedFactors.length > 0) {\n                    nextLevel = \"aal2\";\n                }\n                const currentAuthenticationMethods = payload.amr || [];\n                return {\n                    data: {\n                        currentLevel,\n                        nextLevel,\n                        currentAuthenticationMethods\n                    },\n                    error: null\n                };\n            });\n        });\n    }\n    async fetchJwk(kid, jwks = {\n        keys: []\n    }) {\n        // try fetching from the supplied jwks\n        let jwk = jwks.keys.find((key)=>key.kid === kid);\n        if (jwk) {\n            return jwk;\n        }\n        // try fetching from cache\n        jwk = this.jwks.keys.find((key)=>key.kid === kid);\n        // jwk exists and jwks isn't stale\n        if (jwk && this.jwks_cached_at + _lib_constants__WEBPACK_IMPORTED_MODULE_1__.JWKS_TTL > Date.now()) {\n            return jwk;\n        }\n        // jwk isn't cached in memory so we need to fetch it from the well-known endpoint\n        const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/.well-known/jwks.json`, {\n            headers: this.headers\n        });\n        if (error) {\n            throw error;\n        }\n        if (!data.keys || data.keys.length === 0) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError(\"JWKS is empty\");\n        }\n        this.jwks = data;\n        this.jwks_cached_at = Date.now();\n        // Find the signing key\n        jwk = data.keys.find((key)=>key.kid === kid);\n        if (!jwk) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError(\"No matching signing key found in JWKS\");\n        }\n        return jwk;\n    }\n    /**\n     * @experimental This method may change in future versions.\n     * @description Gets the claims from a JWT. If the JWT is symmetric JWTs, it will call getUser() to verify against the server. If the JWT is asymmetric, it will be verified against the JWKS using the WebCrypto API.\n     */ async getClaims(jwt, jwks = {\n        keys: []\n    }) {\n        try {\n            let token = jwt;\n            if (!token) {\n                const { data, error } = await this.getSession();\n                if (error || !data.session) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                token = data.session.access_token;\n            }\n            const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(token);\n            // Reject expired JWTs\n            (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.validateExp)(payload.exp);\n            // If symmetric algorithm or WebCrypto API is unavailable, fallback to getUser()\n            if (!header.kid || header.alg === \"HS256\" || !(\"crypto\" in globalThis && \"subtle\" in globalThis.crypto)) {\n                const { error } = await this.getUser(token);\n                if (error) {\n                    throw error;\n                }\n                // getUser succeeds so the claims in the JWT can be trusted\n                return {\n                    data: {\n                        claims: payload,\n                        header,\n                        signature\n                    },\n                    error: null\n                };\n            }\n            const algorithm = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getAlgorithm)(header.alg);\n            const signingKey = await this.fetchJwk(header.kid, jwks);\n            // Convert JWK to CryptoKey\n            const publicKey = await crypto.subtle.importKey(\"jwk\", signingKey, algorithm, true, [\n                \"verify\"\n            ]);\n            // Verify the signature\n            const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.stringToUint8Array)(`${rawHeader}.${rawPayload}`));\n            if (!isValid) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError(\"Invalid JWT signature\");\n            }\n            // If verification succeeds, decode and return claims\n            return {\n                data: {\n                    claims: payload,\n                    header,\n                    signature\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n}\nGoTrueClient.nextInstanceID = 0; //# sourceMappingURL=GoTrueClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ3NIO0FBQzRLO0FBQy9OO0FBQ3NJO0FBQ2xLO0FBQ2hDO0FBQ2I7QUFDNkI7QUFDaEI7QUFDckQwQyxrRUFBa0JBLElBQUksOEJBQThCO0FBQ3BELE1BQU1LLGtCQUFrQjtJQUNwQkMsS0FBSzNDLHNEQUFVQTtJQUNmNEMsWUFBWTNDLHVEQUFXQTtJQUN2QjRDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxvQkFBb0I7SUFDcEJDLFNBQVNwRCwyREFBZUE7SUFDeEJxRCxVQUFVO0lBQ1ZDLE9BQU87SUFDUEMsOEJBQThCO0FBQ2xDO0FBQ0EsZUFBZUMsU0FBU0MsSUFBSSxFQUFFQyxjQUFjLEVBQUVDLEVBQUU7SUFDNUMsT0FBTyxNQUFNQTtBQUNqQjtBQUNlLE1BQU1DO0lBQ2pCOztLQUVDLEdBQ0RDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJQyxJQUFJQztRQUNSLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUcsSUFBSUM7UUFDL0IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLHlCQUF5QixHQUFHO1FBQ2pDLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUI7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ3BCLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0ksNEJBQTRCLEdBQUc7UUFDcEMsSUFBSSxDQUFDaUIseUJBQXlCLEdBQUc7UUFDakMsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRTtRQUN2Qjs7U0FF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QztvQkFDSjtvQkFDQXZRLE9BQU87Z0JBQ1g7WUFDSjtZQUNBLE1BQU04USxZQUFZOVYsMERBQVlBLENBQUNzVixPQUFPSyxHQUFHO1lBQ3pDLE1BQU1JLGFBQWEsTUFBTSxJQUFJLENBQUNmLFFBQVEsQ0FBQ00sT0FBT0wsR0FBRyxFQUFFelI7WUFDbkQsMkJBQTJCO1lBQzNCLE1BQU13UyxZQUFZLE1BQU1KLE9BQU9LLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDLE9BQU9ILFlBQVlELFdBQVcsTUFBTTtnQkFDaEY7YUFDSDtZQUNELHVCQUF1QjtZQUN2QixNQUFNSyxVQUFVLE1BQU1QLE9BQU9LLE1BQU0sQ0FBQ25TLE1BQU0sQ0FBQ2dTLFdBQVdFLFdBQVdULFdBQVc5VSxrRUFBa0JBLENBQUMsQ0FBQyxFQUFFZ1YsVUFBVSxDQUFDLEVBQUVDLFdBQVcsQ0FBQztZQUMzSCxJQUFJLENBQUNTLFNBQVM7Z0JBQ1YsTUFBTSxJQUFJclgsNERBQW1CQSxDQUFDO1lBQ2xDO1lBQ0EscURBQXFEO1lBQ3JELE9BQU87Z0JBQ0h1RyxNQUFNO29CQUNGd1EsUUFBUXBJO29CQUNSNkg7b0JBQ0FDO2dCQUNKO2dCQUNBdlEsT0FBTztZQUNYO1FBQ0osRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSXRHLHdEQUFXQSxDQUFDc0csUUFBUTtnQkFDcEIsT0FBTztvQkFBRUssTUFBTTtvQkFBTUw7Z0JBQU07WUFDL0I7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7QUFDSjtBQUNBeEQsYUFBYW9CLGNBQWMsR0FBRyxHQUM5Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQ2xpZW50LmpzPzMwNmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknO1xuaW1wb3J0IHsgREVGQVVMVF9IRUFERVJTLCBFWFBJUllfTUFSR0lOX01TLCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUywgQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xELCBHT1RSVUVfVVJMLCBTVE9SQUdFX0tFWSwgSldLU19UVEwsIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciwgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yLCBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IsIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciwgQXV0aFVua25vd25FcnJvciwgaXNBdXRoQXBpRXJyb3IsIGlzQXV0aEVycm9yLCBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yLCBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCBpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciwgQXV0aEludmFsaWRKd3RFcnJvciwgfSBmcm9tICcuL2xpYi9lcnJvcnMnO1xuaW1wb3J0IHsgX3JlcXVlc3QsIF9zZXNzaW9uUmVzcG9uc2UsIF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCwgX3VzZXJSZXNwb25zZSwgX3Nzb1Jlc3BvbnNlLCB9IGZyb20gJy4vbGliL2ZldGNoJztcbmltcG9ydCB7IERlZmVycmVkLCBnZXRJdGVtQXN5bmMsIGlzQnJvd3NlciwgcmVtb3ZlSXRlbUFzeW5jLCByZXNvbHZlRmV0Y2gsIHNldEl0ZW1Bc3luYywgdXVpZCwgcmV0cnlhYmxlLCBzbGVlcCwgc3VwcG9ydHNMb2NhbFN0b3JhZ2UsIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwsIGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QsIGdldEFsZ29yaXRobSwgdmFsaWRhdGVFeHAsIGRlY29kZUpXVCwgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbmltcG9ydCB7IGxvY2FsU3RvcmFnZUFkYXB0ZXIsIG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2xpYi9sb2NhbC1zdG9yYWdlJztcbmltcG9ydCB7IHBvbHlmaWxsR2xvYmFsVGhpcyB9IGZyb20gJy4vbGliL3BvbHlmaWxscyc7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi9saWIvdmVyc2lvbic7XG5pbXBvcnQgeyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciwgbmF2aWdhdG9yTG9jayB9IGZyb20gJy4vbGliL2xvY2tzJztcbmltcG9ydCB7IHN0cmluZ1RvVWludDhBcnJheSB9IGZyb20gJy4vbGliL2Jhc2U2NHVybCc7XG5wb2x5ZmlsbEdsb2JhbFRoaXMoKTsgLy8gTWFrZSBcImdsb2JhbFRoaXNcIiBhdmFpbGFibGVcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICB1cmw6IEdPVFJVRV9VUkwsXG4gICAgc3RvcmFnZUtleTogU1RPUkFHRV9LRVksXG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gICAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxuICAgIGZsb3dUeXBlOiAnaW1wbGljaXQnLFxuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiBmYWxzZSxcbn07XG5hc3luYyBmdW5jdGlvbiBsb2NrTm9PcChuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICByZXR1cm4gYXdhaXQgZm4oKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvVHJ1ZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFzeW5jIGNsaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogV2hlbiBudWxsIG9yIG5vdCB5ZXQgcmVzb2x2ZWQgdGhlIGF1dGggc3RhdGUgaXMgYHVua25vd25gXG4gICAgICAgICAqIE9uY2UgcmVzb2x2ZWQgdGhlIHRoZSBhdXRoIHN0YXRlIGlzIGtub3duIGFuZCBpdCdzIHNhdmUgdG8gY2FsbCBhbnkgZnVydGhlciBjbGllbnQgbWV0aG9kcy5cbiAgICAgICAgICogS2VlcCBleHRyYSBjYXJlIHRvIG5ldmVyIHJlamVjdCBvciB0aHJvdyB1bmNhdWdodCBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIGJyb2FkY2FzdCBzdGF0ZSBjaGFuZ2UgZXZlbnRzIHRvIG90aGVyIHRhYnMgbGlzdGVuaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjb25zb2xlLmxvZztcbiAgICAgICAgdGhpcy5pbnN0YW5jZUlEID0gR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEO1xuICAgICAgICBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSUQgKz0gMTtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VJRCA+IDAgJiYgaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTXVsdGlwbGUgR29UcnVlQ2xpZW50IGluc3RhbmNlcyBkZXRlY3RlZCBpbiB0aGUgc2FtZSBicm93c2VyIGNvbnRleHQuIEl0IGlzIG5vdCBhbiBlcnJvciwgYnV0IHRoaXMgc2hvdWxkIGJlIGF2b2lkZWQgYXMgaXQgbWF5IHByb2R1Y2UgdW5kZWZpbmVkIGJlaGF2aW9yIHdoZW4gdXNlZCBjb25jdXJyZW50bHkgdW5kZXIgdGhlIHNhbWUgc3RvcmFnZSBrZXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnTWVzc2FnZXMgPSAhIXNldHRpbmdzLmRlYnVnO1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmRlYnVnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IHNldHRpbmdzLmRlYnVnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdFNlc3Npb24gPSBzZXR0aW5ncy5wZXJzaXN0U2Vzc2lvbjtcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3Muc3RvcmFnZUtleTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRva2VuID0gc2V0dGluZ3MuYXV0b1JlZnJlc2hUb2tlbjtcbiAgICAgICAgdGhpcy5hZG1pbiA9IG5ldyBHb1RydWVBZG1pbkFwaSh7XG4gICAgICAgICAgICB1cmw6IHNldHRpbmdzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHNldHRpbmdzLmhlYWRlcnMsXG4gICAgICAgICAgICBmZXRjaDogc2V0dGluZ3MuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVybCA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVycztcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChzZXR0aW5ncy5mZXRjaCk7XG4gICAgICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2sgfHwgbG9ja05vT3A7XG4gICAgICAgIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsID0gc2V0dGluZ3MuZGV0ZWN0U2Vzc2lvbkluVXJsO1xuICAgICAgICB0aGlzLmZsb3dUeXBlID0gc2V0dGluZ3MuZmxvd1R5cGU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IHNldHRpbmdzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI7XG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2NrKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQnJvd3NlcigpICYmICgoX2EgPSBnbG9iYWxUaGlzID09PSBudWxsIHx8IGdsb2JhbFRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMubmF2aWdhdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9ja3MpKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBuYXZpZ2F0b3JMb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gbG9ja05vT3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5qd2tzID0geyBrZXlzOiBbXSB9O1xuICAgICAgICB0aGlzLmp3a3NfY2FjaGVkX2F0ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgIHRoaXMubWZhID0ge1xuICAgICAgICAgICAgdmVyaWZ5OiB0aGlzLl92ZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVucm9sbDogdGhpcy5fZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICAgICAgICB1bmVucm9sbDogdGhpcy5fdW5lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNoYWxsZW5nZTogdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNoYWxsZW5nZUFuZFZlcmlmeTogdGhpcy5fY2hhbGxlbmdlQW5kVmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWw6IHRoaXMuX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0U2Vzc2lvbikge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzZXR0aW5ncy5zdG9yYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gbG9jYWxTdG9yYWdlQWRhcHRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge307XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmIGdsb2JhbFRoaXMuQnJvYWRjYXN0Q2hhbm5lbCAmJiB0aGlzLnBlcnNpc3RTZXNzaW9uICYmIHRoaXMuc3RvcmFnZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBuZXcgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCwgbXVsdGktdGFiIHN0YXRlIGNoYW5nZXMgd2lsbCBub3QgYmUgYXZhaWxhYmxlJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmJyb2FkY2FzdENoYW5uZWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ3JlY2VpdmVkIGJyb2FkY2FzdCBub3RpZmljYXRpb24gZnJvbSBvdGhlciB0YWIgb3IgY2xpZW50JywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKGV2ZW50LmRhdGEuZXZlbnQsIGV2ZW50LmRhdGEuc2Vzc2lvbiwgZmFsc2UpOyAvLyBicm9hZGNhc3QgPSBmYWxzZSBzbyB3ZSBkb24ndCBnZXQgYW4gZW5kbGVzcyBsb29wIG9mIG1lc3NhZ2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgX2RlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubG9nRGVidWdNZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoYEdvVHJ1ZUNsaWVudEAke3RoaXMuaW5zdGFuY2VJRH0gKCR7dmVyc2lvbn0pICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWAsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2xpZW50IHNlc3Npb24gZWl0aGVyIGZyb20gdGhlIHVybCBvciBmcm9tIHN0b3JhZ2UuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjbGllbnQsIGJ1dCBzaG91bGQgYWxzbyBiZSBjYWxsZWRcbiAgICAgKiBtYW51YWxseSB3aGVuIGNoZWNraW5nIGZvciBhbiBlcnJvciBmcm9tIGFuIGF1dGggcmVkaXJlY3QgKG9hdXRoLCBtYWdpY2xpbmssIHBhc3N3b3JkIHJlY292ZXJ5LCBldGMpLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElNUE9SVEFOVDpcbiAgICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogMi4gTmV2ZXIgcmV0dXJuIGEgc2Vzc2lvbiBmcm9tIHRoaXMgbWV0aG9kIGFzIGl0IHdvdWxkIGJlIGNhY2hlZCBvdmVyXG4gICAgICogICAgdGhlIHdob2xlIGxpZmV0aW1lIG9mIHRoZSBjbGllbnRcbiAgICAgKi9cbiAgICBhc3luYyBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICBsZXQgY2FsbGJhY2tVcmxUeXBlID0gJ25vbmUnO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW1wbGljaXRHcmFudENhbGxiYWNrKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja1VybFR5cGUgPSAnaW1wbGljaXQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXdhaXQgdGhpcy5faXNQS0NFQ2FsbGJhY2socGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdwa2NlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXR0ZW1wdCB0byBnZXQgdGhlIHNlc3Npb24gZnJvbSB0aGUgVVJMIG9ubHkgaWYgdGhlc2UgY29uZGl0aW9ucyBhcmUgZnVsZmlsbGVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZTogSWYgdGhlIFVSTCBpc24ndCBvbmUgb2YgdGhlIGNhbGxiYWNrIHVybCB0eXBlcyAoaW1wbGljaXQgb3IgcGtjZSksXG4gICAgICAgICAgICAgKiB0aGVuIHRoZXJlIGNvdWxkIGJlIGFuIGV4aXN0aW5nIHNlc3Npb24gc28gd2UgZG9uJ3Qgd2FudCB0byBwcmVtYXR1cmVseSByZW1vdmUgaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsICYmIGNhbGxiYWNrVXJsVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0U2Vzc2lvbkZyb21VUkwocGFyYW1zLCBjYWxsYmFja1VybFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZXJyb3IgZGV0ZWN0aW5nIHNlc3Npb24gZnJvbSBVUkwnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IChfYSA9IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X2FscmVhZHlfZXhpc3RzJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X25vdF9mb3VuZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdzaW5nbGVfaWRlbnRpdHlfbm90X2RlbGV0YWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhaWxlZCBsb2dpbiBhdHRlbXB0IHZpYSB1cmwsXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgc2Vzc2lvbiBhcyBpbiB2ZXJpZnlPdHAsIHNpZ25VcCBhbmQgc2lnbkluV2l0aCpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZSB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZGV0ZWN0ZWQgc2Vzc2lvbiBpbiBVUkwnLCBzZXNzaW9uLCAncmVkaXJlY3QgdHlwZScsIHJlZGlyZWN0VHlwZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09ICdyZWNvdmVyeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdQQVNTV09SRF9SRUNPVkVSWScsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vIGxvZ2luIGF0dGVtcHQgdmlhIGNhbGxiYWNrIHVybCB0cnkgdG8gcmVjb3ZlciBzZXNzaW9uIGZyb20gc3RvcmFnZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVjb3ZlckFuZFJlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbicsIGVycm9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhbm9ueW1vdXMgdXNlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc2Vzc2lvbiB3aGVyZSB0aGUgaXNfYW5vbnltb3VzIGNsYWltIGluIHRoZSBhY2Nlc3MgdG9rZW4gSldUIHNldCB0byB0cnVlXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluQW5vbnltb3VzbHkoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9iID0gKF9hID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9jID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gZGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCBpZiBhIHVzZXIgYWNjb3VudCBleGlzdHMgaW4gdGhlIHN5c3RlbSB5b3UgbWF5IGdldCBiYWNrIGFuXG4gICAgICogZXJyb3IgbWVzc2FnZSB0aGF0IGF0dGVtcHRzIHRvIGhpZGUgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyLlxuICAgICAqIFRoaXMgbWV0aG9kIGhhcyBzdXBwb3J0IGZvciBQS0NFIHZpYSBlbWFpbCBzaWdudXBzLiBUaGUgUEtDRSBmbG93IGNhbm5vdCBiZSB1c2VkIHdoZW4gYXV0b2NvbmZpcm0gaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbG9nZ2VkLWluIHNlc3Npb24gaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9OXG4gICAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICAgKi9cbiAgICBhc3luYyBzaWduVXAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnc21zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciB3aXRoIGFuIGVtYWlsIGFuZCBwYXNzd29yZCBvciBwaG9uZSBhbmQgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAgICogYmV0d2VlbiB0aGUgY2FzZXMgd2hlcmUgdGhlIGFjY291bnQgZG9lcyBub3QgZXhpc3Qgb3IgdGhhdCB0aGVcbiAgICAgKiBlbWFpbC9waG9uZSBhbmQgcGFzc3dvcmQgY29tYmluYXRpb24gaXMgd3Jvbmcgb3IgdGhhdCB0aGUgYWNjb3VudCBjYW4gb25seVxuICAgICAqIGJlIGFjY2Vzc2VkIHZpYSBzb2NpYWwgbG9naW4uXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aFBhc3N3b3JkKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wYXNzd29yZGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyB1c2VyOiBkYXRhLnVzZXIsIHNlc3Npb246IGRhdGEuc2Vzc2lvbiB9LCAoZGF0YS53ZWFrX3Bhc3N3b3JkID8geyB3ZWFrUGFzc3dvcmQ6IGRhdGEud2Vha19wYXNzd29yZCB9IDogbnVsbCkpLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHZpYSBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aE9BdXRoKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZVByb3ZpZGVyU2lnbkluKGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiAoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3BlczogKF9iID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiAoX2MgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiAoX2QgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2tpcEJyb3dzZXJSZWRpcmVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIGJ5IGV4Y2hhbmdpbmcgYW4gQXV0aCBDb2RlIGlzc3VlZCBkdXJpbmcgdGhlIFBLQ0UgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBleGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgY29uc3QgW2NvZGVWZXJpZmllciwgcmVkaXJlY3RUeXBlXSA9IChzdG9yYWdlSXRlbSAhPT0gbnVsbCAmJiBzdG9yYWdlSXRlbSAhPT0gdm9pZCAwID8gc3RvcmFnZUl0ZW0gOiAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGtjZWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBhdXRoX2NvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyByZWRpcmVjdFR5cGU6IHJlZGlyZWN0VHlwZSAhPT0gbnVsbCAmJiByZWRpcmVjdFR5cGUgIT09IHZvaWQgMCA/IHJlZGlyZWN0VHlwZSA6IG51bGwgfSksIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyBzaWduaW5nIGluIHdpdGggYW4gT0lEQyBJRCB0b2tlbi4gVGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHVzZWRcbiAgICAgKiBzaG91bGQgYmUgZW5hYmxlZCBhbmQgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoSWRUb2tlbihjcmVkZW50aWFscykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zLCBwcm92aWRlciwgdG9rZW4sIGFjY2Vzc190b2tlbiwgbm9uY2UgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgaWRfdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIG1hZ2ljbGluayBvciBhIG9uZS10aW1lIHBhc3N3b3JkIChPVFApLlxuICAgICAqXG4gICAgICogSWYgdGhlIGB7eyAuQ29uZmlybWF0aW9uVVJMIH19YCB2YXJpYWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGVtYWlsIHRlbXBsYXRlLCBhIG1hZ2ljbGluayB3aWxsIGJlIHNlbnQuXG4gICAgICogSWYgdGhlIGB7eyAuVG9rZW4gfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGFuIE9UUCB3aWxsIGJlIHNlbnQuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIHBob25lIHNpZ24taW5zLCBvbmx5IGFuIE9UUCB3aWxsIGJlIHNlbnQuIFlvdSB3b24ndCBiZSBhYmxlIHRvIHNlbmQgYSBtYWdpY2xpbmsgZm9yIHBob25lIHNpZ24taW5zLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCB5b3UgbWF5IGdldCBiYWNrIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCB3aWxsIG5vdCBkaXN0aW5ndWlzaFxuICAgICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yLCB0aGF0IHRoZSBhY2NvdW50XG4gICAgICogY2FuIG9ubHkgYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICAgKlxuICAgICAqIERvIG5vdGUgdGhhdCB5b3Ugd2lsbCBuZWVkIHRvIGNvbmZpZ3VyZSBhIFdoYXRzYXBwIHNlbmRlciBvbiBUd2lsaW9cbiAgICAgKiBpZiB5b3UgYXJlIHVzaW5nIHBob25lIHNpZ24gaW4gd2l0aCB0aGUgJ3doYXRzYXBwJyBjaGFubmVsLiBUaGUgd2hhdHNhcHBcbiAgICAgKiBjaGFubmVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gb3RoZXIgcHJvdmlkZXJzXG4gICAgICogYXQgdGhpcyB0aW1lLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIFBLQ0Ugd2hlbiBhbiBlbWFpbCBpcyBwYXNzZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aE90cChjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb3RwYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3VzZXI6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaG91bGRDcmVhdGVVc2VyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L290cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZV91c2VyOiAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2hvdWxkQ3JlYXRlVXNlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVsKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAnc21zJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm1lc3NhZ2VfaWQgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgZ2l2ZW4gYSBVc2VyIHN1cHBsaWVkIE9UUCBvciBUb2tlbkhhc2ggcmVjZWl2ZWQgdGhyb3VnaCBtb2JpbGUgb3IgZW1haWwuXG4gICAgICovXG4gICAgYXN5bmMgdmVyaWZ5T3RwKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlZGlyZWN0VG8gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgY2FwdGNoYVRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCdvcHRpb25zJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvO1xuICAgICAgICAgICAgICAgIGNhcHRjaGFUb2tlbiA9IChfYiA9IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FwdGNoYVRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdmVyaWZ5YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogY2FwdGNoYVRva2VuIH0gfSksXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIG9uIHRva2VuIHZlcmlmaWNhdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycyhwYXJhbXMudHlwZSA9PSAncmVjb3ZlcnknID8gJ1BBU1NXT1JEX1JFQ09WRVJZJyA6ICdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgYSBzaW5nbGUtc2lnbiBvbiB1c2luZyBhbiBlbnRlcnByaXNlIElkZW50aXR5IFByb3ZpZGVyLiBBXG4gICAgICogc3VjY2Vzc2Z1bCBTU08gYXR0ZW1wdCB3aWxsIHJlZGlyZWN0IHRoZSBjdXJyZW50IHBhZ2UgdG8gdGhlIGlkZW50aXR5XG4gICAgICogcHJvdmlkZXIgYXV0aG9yaXphdGlvbiBwYWdlLiBUaGUgcmVkaXJlY3QgVVJMIGlzIGltcGxlbWVudGF0aW9uIGFuZCBTU09cbiAgICAgKiBwcm90b2NvbCBzcGVjaWZpYy5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gdXNlIGl0IGJ5IHByb3ZpZGluZyBhIFNTTyBkb21haW4uIFR5cGljYWxseSB5b3UgY2FuIGV4dHJhY3QgdGhpc1xuICAgICAqIGRvbWFpbiBieSBhc2tpbmcgdXNlcnMgZm9yIHRoZWlyIGVtYWlsIGFkZHJlc3MuIElmIHRoaXMgZG9tYWluIGlzXG4gICAgICogcmVnaXN0ZXJlZCBvbiB0aGUgQXV0aCBpbnN0YW5jZSB0aGUgcmVkaXJlY3Qgd2lsbCB1c2UgdGhhdCBvcmdhbml6YXRpb24nc1xuICAgICAqIGN1cnJlbnRseSBhY3RpdmUgU1NPIElkZW50aXR5IFByb3ZpZGVyIGZvciB0aGUgbG9naW4uXG4gICAgICpcbiAgICAgKiBJZiB5b3UgaGF2ZSBidWlsdCBhbiBvcmdhbml6YXRpb24tc3BlY2lmaWMgbG9naW4gcGFnZSwgeW91IGNhbiB1c2UgdGhlXG4gICAgICogb3JnYW5pemF0aW9uJ3MgU1NPIElkZW50aXR5IFByb3ZpZGVyIFVVSUQgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoU1NPKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc3NvYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKCdwcm92aWRlcklkJyBpbiBwYXJhbXMgPyB7IHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZCB9IDogbnVsbCkpLCAoJ2RvbWFpbicgaW4gcGFyYW1zID8geyBkb21haW46IHBhcmFtcy5kb21haW4gfSA6IG51bGwpKSwgeyByZWRpcmVjdF90bzogKF9iID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQgfSksICgoKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgID8geyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBwYXJhbXMub3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLCB7IHNraXBfaHR0cF9yZWRpcmVjdDogdHJ1ZSwgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCB9KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zc29SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHJlYXV0aGVudGljYXRpb24gT1RQIHRvIHRoZSB1c2VyJ3MgZW1haWwgb3IgcGhvbmUgbnVtYmVyLlxuICAgICAqIFJlcXVpcmVzIHRoZSB1c2VyIHRvIGJlIHNpZ25lZC1pbi5cbiAgICAgKi9cbiAgICBhc3luYyByZWF1dGhlbnRpY2F0ZSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVhdXRoZW50aWNhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9yZWF1dGhlbnRpY2F0ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHNlc3Npb25FcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vcmVhdXRoZW50aWNhdGVgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZW5kcyBhbiBleGlzdGluZyBzaWdudXAgY29uZmlybWF0aW9uIGVtYWlsLCBlbWFpbCBjaGFuZ2UgZW1haWwsIFNNUyBPVFAgb3IgcGhvbmUgY2hhbmdlIE9UUC5cbiAgICAgKi9cbiAgICBhc3luYyByZXNlbmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy51cmx9L3Jlc2VuZGA7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm1lc3NhZ2VfaWQgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXNzaW9uLCByZWZyZXNoaW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXNzaW9uIHJldHVybmVkIGNhbiBiZSBudWxsIGlmIHRoZSBzZXNzaW9uIGlzIG5vdCBkZXRlY3RlZCB3aGljaCBjYW4gaGFwcGVuIGluIHRoZSBldmVudCBhIHVzZXIgaXMgbm90IHNpZ25lZC1pbiBvciBoYXMgbG9nZ2VkIG91dC5cbiAgICAgKlxuICAgICAqICoqSU1QT1JUQU5UOioqIFRoaXMgbWV0aG9kIGxvYWRzIHZhbHVlcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIGF0dGFjaGVkXG4gICAgICogdG8gdGhlIGNsaWVudC4gSWYgdGhhdCBzdG9yYWdlIGlzIGJhc2VkIG9uIHJlcXVlc3QgY29va2llcyBmb3IgZXhhbXBsZSxcbiAgICAgKiB0aGUgdmFsdWVzIGluIGl0IG1heSBub3QgYmUgYXV0aGVudGljIGFuZCB0aGVyZWZvcmUgaXQncyBzdHJvbmdseSBhZHZpc2VkXG4gICAgICogYWdhaW5zdCB1c2luZyB0aGlzIG1ldGhvZCBhbmQgaXRzIHJlc3VsdHMgaW4gc3VjaCBjaXJjdW1zdGFuY2VzLiBBIHdhcm5pbmdcbiAgICAgKiB3aWxsIGJlIGVtaXR0ZWQgaWYgdGhpcyBpcyBkZXRlY3RlZC4gVXNlIHtAbGluayAjZ2V0VXNlcigpfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgYSBnbG9iYWwgbG9jayBiYXNlZCBvbiB0aGUgc3RvcmFnZSBrZXkuXG4gICAgICovXG4gICAgYXN5bmMgX2FjcXVpcmVMb2NrKGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdiZWdpbicsIGFjcXVpcmVUaW1lb3V0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wZW5kaW5nSW5Mb2NrW3RoaXMucGVuZGluZ0luTG9jay5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9jayhgbG9jazoke3RoaXMuc3RvcmFnZUtleX1gLCBhY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgYWNxdWlyZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgZHJhaW5pbmcgdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWl0T24gPSBbLi4udGhpcy5wZW5kaW5nSW5Mb2NrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHdhaXRPbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2suc3BsaWNlKDAsIHdhaXRPbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIHJlbGVhc2VkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgaW5zdGVhZCBvZiB7QGxpbmsgI2dldFNlc3Npb259IGluc2lkZSB0aGUgbGlicmFyeS4gSXQgaXNcbiAgICAgKiBzZW1hbnRpY2FsbHkgdXN1YWxseSB3aGF0IHlvdSB3YW50LCBhcyBnZXR0aW5nIGEgc2Vzc2lvbiBpbnZvbHZlcyBzb21lXG4gICAgICogcHJvY2Vzc2luZyBhZnRlcndhcmRzIHRoYXQgcmVxdWlyZXMgb25seSBvbmUgY2xpZW50IG9wZXJhdGluZyBvbiB0aGVcbiAgICAgKiBzZXNzaW9uIGF0IG9uY2UgYWNyb3NzIG11bHRpcGxlIHRhYnMgb3IgcHJvY2Vzc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIF91c2VTZXNzaW9uKGZuKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRoZSB1c2Ugb2YgX19sb2FkU2Vzc2lvbiBoZXJlIGlzIHRoZSBvbmx5IGNvcnJlY3QgdXNlIG9mIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX19sb2FkU2Vzc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5FVkVSIFVTRSBESVJFQ1RMWSFcbiAgICAgKlxuICAgICAqIEFsd2F5cyB1c2Uge0BsaW5rICNfdXNlU2Vzc2lvbn0uXG4gICAgICovXG4gICAgYXN5bmMgX19sb2FkU2Vzc2lvbigpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnYmVnaW4nKTtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAndXNlZCBvdXRzaWRlIG9mIGFuIGFjcXVpcmVkIGxvY2shJywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbWF5YmVTZXNzaW9uID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgbWF5YmVTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChtYXliZVNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IG1heWJlU2Vzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBzZXNzaW9uIGlzIGNvbnNpZGVyZWQgZXhwaXJlZCBiZWZvcmUgdGhlIGFjY2VzcyB0b2tlbiBfYWN0dWFsbHlfXG4gICAgICAgICAgICAvLyBleHBpcmVzLiBXaGVuIHRoZSBhdXRvUmVmcmVzaFRva2VuIG9wdGlvbiBpcyBvZmYgKG9yIHdoZW4gdGhlIHRhYiBpc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGJhY2tncm91bmQpLCB2ZXJ5IGVhZ2VyIHVzZXJzIG9mIGdldFNlc3Npb24oKSAtLSBsaWtlXG4gICAgICAgICAgICAvLyByZWFsdGltZS1qcyAtLSBtaWdodCBzZW5kIGEgdmFsaWQgSldUIHdoaWNoIHdpbGwgZXhwaXJlIGJ5IHRoZSB0aW1lIGl0XG4gICAgICAgICAgICAvLyByZWFjaGVzIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICAgICAgICAgID8gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBEYXRlLm5vdygpIDwgRVhQSVJZX01BUkdJTl9NU1xuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsIGBzZXNzaW9uIGhhcyR7aGFzRXhwaXJlZCA/ICcnIDogJyBub3QnfSBleHBpcmVkYCwgJ2V4cGlyZXNfYXQnLCBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KTtcbiAgICAgICAgICAgIGlmICghaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1cHByZXNzV2FybmluZyA9IHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJveHlTZXNzaW9uID0gbmV3IFByb3h5KGN1cnJlbnRTZXNzaW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdXBwcmVzc1dhcm5pbmcgJiYgcHJvcCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgc2hvdyB3YXJuaW5nIHdoZW4gdGhlIHVzZXIgb2JqZWN0IGlzIGJlaW5nIGFjY2Vzc2VkIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VzaW5nIHRoZSB1c2VyIG9iamVjdCBhcyByZXR1cm5lZCBmcm9tIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpIG9yIGZyb20gc29tZSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKCkgZXZlbnRzIGNvdWxkIGJlIGluc2VjdXJlISBUaGlzIHZhbHVlIGNvbWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgbWVkaXVtICh1c3VhbGx5IGNvb2tpZXMgb24gdGhlIHNlcnZlcikgYW5kIG1heSBub3QgYmUgYXV0aGVudGljLiBVc2Ugc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCkgaW5zdGVhZCB3aGljaCBhdXRoZW50aWNhdGVzIHRoZSBkYXRhIGJ5IGNvbnRhY3RpbmcgdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwcmVzc1dhcm5pbmcgPSB0cnVlOyAvLyBrZWVwcyB0aGlzIHByb3h5IGluc3RhbmNlIGZyb20gbG9nZ2luZyBhZGRpdGlvbmFsIHdhcm5pbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7IC8vIGtlZXBzIHRoaXMgY2xpZW50J3MgZnV0dXJlIHByb3h5IGluc3RhbmNlcyBmcm9tIHdhcm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gcHJveHlTZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGN1cnJlbnRTZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdXNlciBkZXRhaWxzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlc3Npb24uIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBuZXR3b3JrIHJlcXVlc3QgdG8gdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLCBzbyB0aGUgcmV0dXJuZWRcbiAgICAgKiB2YWx1ZSBpcyBhdXRoZW50aWMgYW5kIGNhbiBiZSB1c2VkIHRvIGJhc2UgYXV0aG9yaXphdGlvbiBydWxlcyBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXIoand0KSB7XG4gICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKGp3dCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VXNlcihqd3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogand0LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGFjY2Vzc190b2tlbiBvciBjdXN0b20gYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICYmICF0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9jID0gKF9iID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEpXVCBjb250YWlucyBhIGBzZXNzaW9uX2lkYCB3aGljaCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGFuIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXNzaW9uIGluIHRoZSBkYXRhYmFzZSwgaW5kaWNhdGluZyB0aGUgdXNlciBpcyBzaWduZWQgb3V0LlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBkYXRhIGZvciBhIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlVXNlcihhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbkRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHNlc3Npb25EYXRhLnNlc3Npb247XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnICYmIGF0dHJpYnV0ZXMuZW1haWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCB7IGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLCBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QgfSksXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHVzZXJFcnJvcjtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb24uIElmIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgZXhwaXJlZCwgc2V0U2Vzc2lvbiB3aWxsIHRha2UgY2FyZSBvZiByZWZyZXNoaW5nIGl0IHRvIG9idGFpbiBhIG5ldyBzZXNzaW9uLlxuICAgICAqIElmIHRoZSByZWZyZXNoIHRva2VuIG9yIGFjY2VzcyB0b2tlbiBpbiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uIHRoYXQgbWluaW1hbGx5IGNvbnRhaW5zIGFuIGFjY2VzcyB0b2tlbiBhbmQgcmVmcmVzaCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NldFNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NldFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuIHx8ICFjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lTm93ID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdztcbiAgICAgICAgICAgIGxldCBoYXNFeHBpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gZGVjb2RlSldUKGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5leHApIHtcbiAgICAgICAgICAgICAgICBleHBpcmVzQXQgPSBwYXlsb2FkLmV4cDtcbiAgICAgICAgICAgICAgICBoYXNFeHBpcmVkID0gZXhwaXJlc0F0IDw9IHRpbWVOb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbjogcmVmcmVzaGVkU2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZyZXNoZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gcmVmcmVzaGVkU2Vzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzQXQgLSB0aW1lTm93LFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzZXNzaW9uLCByZWdhcmRsZXNzIG9mIGV4cGlyeSBzdGF0dXMuXG4gICAgICogVGFrZXMgaW4gYW4gb3B0aW9uYWwgY3VycmVudCBzZXNzaW9uLiBJZiBub3QgcGFzc2VkIGluLCB0aGVuIHJlZnJlc2hTZXNzaW9uKCkgd2lsbCBhdHRlbXB0IHRvIHJldHJpZXZlIGl0IGZyb20gZ2V0U2Vzc2lvbigpLlxuICAgICAqIElmIHRoZSBjdXJyZW50IHNlc3Npb24ncyByZWZyZXNoIHRva2VuIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uLiBJZiBwYXNzZWQgaW4sIGl0IG11c3QgY29udGFpbiBhIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gKF9hID0gZGF0YS5zZXNzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRTZXNzaW9uID09PSBudWxsIHx8IGN1cnJlbnRTZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIGEgVVJMIHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIF9nZXRTZXNzaW9uRnJvbVVSTChwYXJhbXMsIGNhbGxiYWNrVXJsVHlwZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBicm93c2VyIGRldGVjdGVkLicpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciBpbiB0aGUgVVJMLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IGZsb3cgaXQgaXMsIHdlIGp1c3QgcmV0dXJuIHRoZSBlcnJvci5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZXJyb3IgfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uIHx8IHBhcmFtcy5lcnJvcl9jb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yIGNsYXNzIHJldHVybmVkIGltcGxpZXMgdGhhdCB0aGUgcmVkaXJlY3QgaXMgZnJvbSBhbiBpbXBsaWNpdCBncmFudCBmbG93XG4gICAgICAgICAgICAgICAgLy8gYnV0IGl0IGNvdWxkIGFsc28gYmUgZnJvbSBhIHJlZGlyZWN0IGVycm9yIGZyb20gYSBQS0NFIGZsb3cuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgJ0Vycm9yIGluIFVSTCB3aXRoIHVuc3BlY2lmaWVkIGVycm9yX2Rlc2NyaXB0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogcGFyYW1zLmVycm9yIHx8ICd1bnNwZWNpZmllZF9lcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5lcnJvcl9jb2RlIHx8ICd1bnNwZWNpZmllZF9jb2RlJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgbWlzbWF0Y2hlcyBiZXR3ZWVuIHRoZSBmbG93VHlwZSBpbml0aWFsaXNlZCBpbiB0aGUgY2xpZW50IGFuZCB0aGUgVVJMIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHN3aXRjaCAoY2FsbGJhY2tVcmxUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1wbGljaXQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yKCdOb3QgYSB2YWxpZCBQS0NFIGZsb3cgdXJsLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BrY2UnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ2ltcGxpY2l0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm90IGEgdmFsaWQgaW1wbGljaXQgZ3JhbnQgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG1pc21hdGNoIHNvIHdlIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgcmVkaXJlY3QgZm9yIFBLQ0UsIHdlIGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIGNvZGUgZnJvbSB0aGUgVVJMIGZvciB0aGUgY29kZSBleGNoYW5nZVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrVXJsVHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfaW5pdGlhbGl6ZSgpJywgJ2JlZ2luJywgJ2lzIFBLQ0UgZmxvdycsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW1zLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vIGNvZGUgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihwYXJhbXMuY29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnY29kZScpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgJycsIHVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGRhdGEuc2Vzc2lvbiwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyX3Rva2VuLCBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLCBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4sIGV4cGlyZXNfaW4sIGV4cGlyZXNfYXQsIHRva2VuX3R5cGUsIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBpZiAoIWFjY2Vzc190b2tlbiB8fCAhZXhwaXJlc19pbiB8fCAhcmVmcmVzaF90b2tlbiB8fCAhdG9rZW5fdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIHNlc3Npb24gZGVmaW5lZCBpbiBVUkwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IHBhcnNlSW50KGV4cGlyZXNfaW4pO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3cgKyBleHBpcmVzSW47XG4gICAgICAgICAgICBpZiAoZXhwaXJlc19hdCkge1xuICAgICAgICAgICAgICAgIGV4cGlyZXNBdCA9IHBhcnNlSW50KGV4cGlyZXNfYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWN0dWFsbHlFeHBpcmVzSW4gPSBleHBpcmVzQXQgLSB0aW1lTm93O1xuICAgICAgICAgICAgaWYgKGFjdHVhbGx5RXhwaXJlc0luICogMTAwMCA8PSBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgZXhwaXJlcyBpbiAke2FjdHVhbGx5RXhwaXJlc0lufXMsIHNob3VsZCBoYXZlIGJlZW4gY2xvc2VyIHRvICR7ZXhwaXJlc0lufXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzc3VlZEF0ID0gZXhwaXJlc0F0IC0gZXhwaXJlc0luO1xuICAgICAgICAgICAgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA+PSAxMjApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgb3ZlciAxMjBzIGFnbywgVVJMIGNvdWxkIGJlIHN0YWxlJywgaXNzdWVkQXQsIGV4cGlyZXNBdCwgdGltZU5vdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lTm93IC0gaXNzdWVkQXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCB3YXMgaXNzdWVkIGluIHRoZSBmdXR1cmU/IENoZWNrIHRoZSBkZXZpY2UgY2xvY2sgZm9yIHNrZXcnLCBpc3N1ZWRBdCwgZXhwaXJlc0F0LCB0aW1lTm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJfdG9rZW4sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19pbjogZXhwaXJlc0luLFxuICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIHRva2VuX3R5cGUsXG4gICAgICAgICAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0b2tlbnMgZnJvbSBVUkxcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19nZXRTZXNzaW9uRnJvbVVSTCgpJywgJ2NsZWFyaW5nIHdpbmRvdy5sb2NhdGlvbi5oYXNoJyk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZTogcGFyYW1zLnR5cGUgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBjb250YWlucyBwYXJhbWV0ZXJzIGdpdmVuIGJ5IGFuIGltcGxpY2l0IG9hdXRoIGdyYW50IGZsb3cgKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2NzQ5Lmh0bWwjc2VjdGlvbi00LjIpXG4gICAgICovXG4gICAgX2lzSW1wbGljaXRHcmFudENhbGxiYWNrKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgYW5kIGJhY2tpbmcgc3RvcmFnZSBjb250YWluIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYSBQS0NFIGZsb3dcbiAgICAgKi9cbiAgICBhc3luYyBfaXNQS0NFQ2FsbGJhY2socGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdG9yYWdlQ29udGVudCA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICByZXR1cm4gISEocGFyYW1zLmNvZGUgJiYgY3VycmVudFN0b3JhZ2VDb250ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zaWRlIGEgYnJvd3NlciBjb250ZXh0LCBgc2lnbk91dCgpYCB3aWxsIHJlbW92ZSB0aGUgbG9nZ2VkIGluIHVzZXIgZnJvbSB0aGUgYnJvd3NlciBzZXNzaW9uIGFuZCBsb2cgdGhlbSBvdXQgLSByZW1vdmluZyBhbGwgaXRlbXMgZnJvbSBsb2NhbHN0b3JhZ2UgYW5kIHRoZW4gdHJpZ2dlciBhIGBcIlNJR05FRF9PVVRcImAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBGb3Igc2VydmVyLXNpZGUgbWFuYWdlbWVudCwgeW91IGNhbiByZXZva2UgYWxsIHJlZnJlc2ggdG9rZW5zIGZvciBhIHVzZXIgYnkgcGFzc2luZyBhIHVzZXIncyBKV1QgdGhyb3VnaCB0byBgYXV0aC5hcGkuc2lnbk91dChKV1Q6IHN0cmluZylgLlxuICAgICAqIFRoZXJlIGlzIG5vIHdheSB0byByZXZva2UgYSB1c2VyJ3MgYWNjZXNzIHRva2VuIGp3dCB1bnRpbCBpdCBleHBpcmVzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgYSBzaG9ydGVyIGV4cGlyeSBvbiB0aGUgand0IGZvciB0aGlzIHJlYXNvbi5cbiAgICAgKlxuICAgICAqIElmIHVzaW5nIGBvdGhlcnNgIHNjb3BlLCBubyBgU0lHTkVEX09VVGAgZXZlbnQgaXMgZmlyZWQhXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk91dChvcHRpb25zID0geyBzY29wZTogJ2dsb2JhbCcgfSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zaWduT3V0KG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NpZ25PdXQoeyBzY29wZSB9ID0geyBzY29wZTogJ2dsb2JhbCcgfSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuYWRtaW4uc2lnbk91dChhY2Nlc3NUb2tlbiwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgNDA0cyBzaW5jZSB1c2VyIG1pZ2h0IG5vdCBleGlzdCBhbnltb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSA0MDFzIHNpbmNlIGFuIGludmFsaWQgb3IgZXhwaXJlZCBKV1Qgc2hvdWxkIHNpZ24gb3V0IHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXNBdXRoQXBpRXJyb3IoZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3Iuc3RhdHVzID09PSA0MDQgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDMpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY29wZSAhPT0gJ290aGVycycpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSBhIG5vdGlmaWNhdGlvbiBldmVyeSB0aW1lIGFuIGF1dGggZXZlbnQgaGFwcGVucy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgICAqL1xuICAgIG9uQXV0aFN0YXRlQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdXVpZCgpO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI3Vuc3Vic2NyaWJlKCknLCAnc3RhdGUgY2hhbmdlIGNhbGxiYWNrIHdpdGggaWQgcmVtb3ZlZCcsIGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjb25BdXRoU3RhdGVDaGFuZ2UoKScsICdyZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggaWQnLCBpZCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5zZXQoaWQsIHN1YnNjcmlwdGlvbik7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0SW5pdGlhbFNlc3Npb24oaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc3Vic2NyaXB0aW9uIH0gfTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXRJbml0aWFsU2Vzc2lvbihpZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2EgPSB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBzZXNzaW9uKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnc2Vzc2lvbicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgcmVxdWVzdCB0byBhbiBlbWFpbCBhZGRyZXNzLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIFVSTCB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgY2xpY2sgdGhlIHBhc3N3b3JkIHJlc2V0IGxpbmsuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2FwdGNoYVRva2VuIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXNldFBhc3N3b3JkRm9yRW1haWwoZW1haWwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgdHJ1ZSAvLyBpc1Bhc3N3b3JkUmVjb3ZlcnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9yZWNvdmVyYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHRoZSBpZGVudGl0aWVzIGxpbmtlZCB0byBhIHVzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlcklkZW50aXRpZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBpZGVudGl0aWVzOiAoX2EgPSBkYXRhLnVzZXIuaWRlbnRpdGllcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlua3MgYW4gb2F1dGggaWRlbnRpdHkgdG8gYW4gZXhpc3RpbmcgdXNlci5cbiAgICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgICAqL1xuICAgIGFzeW5jIGxpbmtJZGVudGl0eShjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX2dldFVybEZvclByb3ZpZGVyKGAke3RoaXMudXJsfS91c2VyL2lkZW50aXRpZXMvYXV0aG9yaXplYCwgY3JlZGVudGlhbHMucHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogKF9hID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlczogKF9iID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjb3BlcyxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IChfYyA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIHVybCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9lID0gKF9kID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhKChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyOiBjcmVkZW50aWFscy5wcm92aWRlciwgdXJsOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudXJsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5saW5rcyBhbiBpZGVudGl0eSBmcm9tIGEgdXNlciBieSBkZWxldGluZyBpdC4gVGhlIHVzZXIgd2lsbCBubyBsb25nZXIgYmUgYWJsZSB0byBzaWduIGluIHdpdGggdGhhdCBpZGVudGl0eSBvbmNlIGl0J3MgdW5saW5rZWQuXG4gICAgICovXG4gICAgYXN5bmMgdW5saW5rSWRlbnRpdHkoaWRlbnRpdHkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L3VzZXIvaWRlbnRpdGllcy8ke2lkZW50aXR5LmlkZW50aXR5X2lkfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBKV1QuXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBBIHZhbGlkIHJlZnJlc2ggdG9rZW4gdGhhdCB3YXMgcmV0dXJuZWQgb24gbG9naW4uXG4gICAgICovXG4gICAgYXN5bmMgX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gYCNfcmVmcmVzaEFjY2Vzc1Rva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAvLyB3aWxsIGF0dGVtcHQgdG8gcmVmcmVzaCB0aGUgdG9rZW4gd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmV0cnlhYmxlKGFzeW5jIChhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSk7IC8vIDIwMCwgNDAwLCA4MDAsIC4uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoaW5nIGF0dGVtcHQnLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1yZWZyZXNoX3Rva2VuYCwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiB7IHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgKGF0dGVtcHQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEJhY2tPZmZJbnRlcnZhbCA9IDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0cnlhYmxlIG9ubHkgaWYgdGhlIHJlcXVlc3QgY2FuIGJlIHNlbnQgYmVmb3JlIHRoZSBiYWNrb2ZmIG92ZXJmbG93cyB0aGUgdGljayBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBEYXRlLm5vdygpICsgbmV4dEJhY2tPZmZJbnRlcnZhbCAtIHN0YXJ0ZWRBdCA8IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pc1ZhbGlkU2Vzc2lvbihtYXliZVNlc3Npb24pIHtcbiAgICAgICAgY29uc3QgaXNWYWxpZFNlc3Npb24gPSB0eXBlb2YgbWF5YmVTZXNzaW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgbWF5YmVTZXNzaW9uICE9PSBudWxsICYmXG4gICAgICAgICAgICAnYWNjZXNzX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICAgICAgICdyZWZyZXNoX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICAgICAgICdleHBpcmVzX2F0JyBpbiBtYXliZVNlc3Npb247XG4gICAgICAgIHJldHVybiBpc1ZhbGlkU2Vzc2lvbjtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZVByb3ZpZGVyU2lnbkluKHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX2dldFVybEZvclByb3ZpZGVyKGAke3RoaXMudXJsfS9hdXRob3JpemVgLCBwcm92aWRlciwge1xuICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgc2NvcGVzOiBvcHRpb25zLnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBvcHRpb25zLnF1ZXJ5UGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlUHJvdmlkZXJTaWduSW4oKScsICdwcm92aWRlcicsIHByb3ZpZGVyLCAnb3B0aW9ucycsIG9wdGlvbnMsICd1cmwnLCB1cmwpO1xuICAgICAgICAvLyB0cnkgdG8gb3BlbiBvbiB0aGUgYnJvd3NlclxuICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgIW9wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXIsIHVybCB9LCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvdmVycyB0aGUgc2Vzc2lvbiBmcm9tIExvY2FsU3RvcmFnZSBhbmQgcmVmcmVzaGVzIHRoZSB0b2tlblxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIGFzeW5jIHRvIGFjY29tbW9kYXRlIGZvciBBc3luY1N0b3JhZ2UgZS5nLiBpbiBSZWFjdCBuYXRpdmUuXG4gICAgICovXG4gICAgYXN5bmMgX3JlY292ZXJBbmRSZWZyZXNoKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9ICcjX3JlY292ZXJBbmRSZWZyZXNoKCknO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFNlc3Npb24gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UnLCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhwaXJlc1dpdGhNYXJnaW4gPSAoKF9hID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHkpICogMTAwMCAtIERhdGUubm93KCkgPCBFWFBJUllfTUFSR0lOX01TO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCBgc2Vzc2lvbiBoYXMke2V4cGlyZXNXaXRoTWFyZ2luID8gJycgOiAnIG5vdCd9IGV4cGlyZWQgd2l0aCBtYXJnaW4gb2YgJHtFWFBJUllfTUFSR0lOX01TfXNgKTtcbiAgICAgICAgICAgIGlmIChleHBpcmVzV2l0aE1hcmdpbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4gJiYgY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3JlZnJlc2ggZmFpbGVkIHdpdGggYSBub24tcmV0cnlhYmxlIGVycm9yLCByZW1vdmluZyB0aGUgc2Vzc2lvbicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHBlcnNpc3QgY3VycmVudFNlc3Npb24gYWdhaW4sIGFzIHdlIGp1c3QgbG9hZGVkIGl0IGZyb21cbiAgICAgICAgICAgICAgICAvLyBsb2NhbCBzdG9yYWdlOyBwZXJzaXN0aW5nIGl0IGFnYWluIG1heSBvdmVyd3JpdGUgYSB2YWx1ZSBzYXZlZCBieVxuICAgICAgICAgICAgICAgIC8vIGFub3RoZXIgY2xpZW50IHdpdGggYWNjZXNzIHRvIHRoZSBzYW1lIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgY3VycmVudFNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9jYWxsUmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVmcmVzaGluZyBpcyBhbHJlYWR5IGluIHByb2dyZXNzXG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gYCNfY2FsbFJlZnJlc2hUb2tlbigke3JlZnJlc2hUb2tlbi5zdWJzdHJpbmcoMCwgNSl9Li4uKWA7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbik7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBpZiAoIWRhdGEuc2Vzc2lvbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnVE9LRU5fUkVGUkVTSEVEJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc2Vzc2lvbjogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX25vdGlmeUFsbFN1YnNjcmliZXJzKGV2ZW50LCBzZXNzaW9uLCBicm9hZGNhc3QgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX25vdGlmeUFsbFN1YnNjcmliZXJzKCR7ZXZlbnR9KWA7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJywgc2Vzc2lvbiwgYGJyb2FkY2FzdCA9ICR7YnJvYWRjYXN0fWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCAmJiBicm9hZGNhc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2UoeyBldmVudCwgc2Vzc2lvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy52YWx1ZXMoKSkubWFwKGFzeW5jICh4KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgeC5jYWxsYmFjayhldmVudCwgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXQgY3VycmVudFNlc3Npb24gYW5kIGN1cnJlbnRVc2VyXG4gICAgICogcHJvY2VzcyB0byBfc3RhcnRBdXRvUmVmcmVzaFRva2VuIGlmIHBvc3NpYmxlXG4gICAgICovXG4gICAgYXN5bmMgX3NhdmVTZXNzaW9uKHNlc3Npb24pIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfc2F2ZVNlc3Npb24oKScsIHNlc3Npb24pO1xuICAgICAgICAvLyBfc2F2ZVNlc3Npb24gaXMgYWx3YXlzIGNhbGxlZCB3aGVuZXZlciBhIG5ldyBzZXNzaW9uIGhhcyBiZWVuIGFjcXVpcmVkXG4gICAgICAgIC8vIHNvIHdlIGNhbiBzYWZlbHkgc3VwcHJlc3MgdGhlIHdhcm5pbmcgcmV0dXJuZWQgYnkgZnV0dXJlIGdldFNlc3Npb24gY2FsbHNcbiAgICAgICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBzZXNzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgX3JlbW92ZVNlc3Npb24oKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3JlbW92ZVNlc3Npb24oKScpO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX09VVCcsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFueSByZWdpc3RlcmVkIHZpc2liaWxpdHljaGFuZ2UgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiB7QHNlZSAjc3RhcnRBdXRvUmVmcmVzaH1cbiAgICAgKiB7QHNlZSAjc3RvcEF1dG9SZWZyZXNofVxuICAgICAqL1xuICAgIF9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCknKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgaXNCcm93c2VyKCkgJiYgKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZW1vdmluZyB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrIGZhaWxlZCcsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rICNzdGFydEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICAgKiB3aXRoaW4gdGhlIGxpYnJhcnkuXG4gICAgICovXG4gICAgYXN5bmMgX3N0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpO1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19zdGFydEF1dG9SZWZyZXNoKCknKTtcbiAgICAgICAgY29uc3QgdGlja2VyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5fYXV0b1JlZnJlc2hUb2tlblRpY2soKSwgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMpO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gdGlja2VyO1xuICAgICAgICBpZiAodGlja2VyICYmIHR5cGVvZiB0aWNrZXIgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aWNrZXIudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHRpY2tlciBpcyBhIE5vZGVKUyBUaW1lb3V0IG9iamVjdCB0aGF0IGhhcyBhbiBgdW5yZWZgIG1ldGhvZFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgICAgICAgIC8vIFdoZW4gYXV0byByZWZyZXNoIGlzIHVzZWQgaW4gTm9kZUpTIChsaWtlIGZvciB0ZXN0aW5nKSB0aGVcbiAgICAgICAgICAgIC8vIGBzZXRJbnRlcnZhbGAgaXMgcHJldmVudGluZyB0aGUgcHJvY2VzcyBmcm9tIGJlaW5nIG1hcmtlZCBhc1xuICAgICAgICAgICAgLy8gZmluaXNoZWQgYW5kIHRlc3RzIHJ1biBlbmRsZXNzbHkuIFRoaXMgY2FuIGJlIHByZXZlbnRlZCBieSBjYWxsaW5nXG4gICAgICAgICAgICAvLyBgdW5yZWYoKWAgb24gdGhlIHJldHVybmVkIG9iamVjdC5cbiAgICAgICAgICAgIHRpY2tlci51bnJlZigpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBoYXMgbm8gY29udGV4dCBvZiBEZW5vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEZW5vLnVucmVmVGltZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHNpbWlsYXIgbGlrZSBmb3IgTm9kZUpTLCBidXQgd2l0aCB0aGUgRGVubyBBUElcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGVuby5sYW5kL2FwaUBsYXRlc3Q/dW5zdGFibGUmcz1EZW5vLnVucmVmVGltZXJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgICAgICAgRGVuby51bnJlZlRpbWVyKHRpY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcnVuIHRoZSB0aWNrIGltbWVkaWF0ZWx5LCBidXQgaW4gdGhlIG5leHQgcGFzcyBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0XG4gICAgICAgIC8vICNfaW5pdGlhbGl6ZSBjYW4gYmUgYWxsb3dlZCB0byBjb21wbGV0ZSB3aXRob3V0IHJlY3Vyc2l2ZWx5IHdhaXRpbmcgb25cbiAgICAgICAgLy8gaXRzZWxmXG4gICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RvcEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICAgKiB3aXRoaW4gdGhlIGxpYnJhcnkuXG4gICAgICovXG4gICAgYXN5bmMgX3N0b3BBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfc3RvcEF1dG9SZWZyZXNoKCknKTtcbiAgICAgICAgY29uc3QgdGlja2VyID0gdGhpcy5hdXRvUmVmcmVzaFRpY2tlcjtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IG51bGw7XG4gICAgICAgIGlmICh0aWNrZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGlja2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYW4gYXV0by1yZWZyZXNoIHByb2Nlc3MgaW4gdGhlIGJhY2tncm91bmQuIFRoZSBzZXNzaW9uIGlzIGNoZWNrZWRcbiAgICAgKiBldmVyeSBmZXcgc2Vjb25kcy4gQ2xvc2UgdG8gdGhlIHRpbWUgb2YgZXhwaXJhdGlvbiBhIHByb2Nlc3MgaXMgc3RhcnRlZCB0b1xuICAgICAqIHJlZnJlc2ggdGhlIHNlc3Npb24uIElmIHJlZnJlc2hpbmcgZmFpbHMgaXQgd2lsbCBiZSByZXRyaWVkIGZvciBhcyBsb25nIGFzXG4gICAgICogbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogSWYgeW91IHNldCB0aGUge0BsaW5rIEdvVHJ1ZUNsaWVudE9wdGlvbnMjYXV0b1JlZnJlc2hUb2tlbn0geW91IGRvbid0IG5lZWRcbiAgICAgKiB0byBjYWxsIHRoaXMgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIGZvciB5b3UuXG4gICAgICpcbiAgICAgKiBPbiBicm93c2VycyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzIG9ubHkgd2hlbiB0aGUgdGFiL3dpbmRvdyBpcyBpbiB0aGVcbiAgICAgKiBmb3JlZ3JvdW5kIHRvIGNvbnNlcnZlIHJlc291cmNlcyBhcyB3ZWxsIGFzIHByZXZlbnQgcmFjZSBjb25kaXRpb25zIGFuZFxuICAgICAqIGZsb29kaW5nIGF1dGggd2l0aCByZXF1ZXN0cy4gSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWRcbiAgICAgKiB2aXNpYmlsaXR5IGNoYW5nZSBjYWxsYmFjayB3aWxsIGJlIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5XG4gICAgICogY2hhbmdlcyBvbiB5b3VyIG93bi5cbiAgICAgKlxuICAgICAqIE9uIG5vbi1icm93c2VyIHBsYXRmb3JtcyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzICpjb250aW51b3VzbHkqIGluIHRoZVxuICAgICAqIGJhY2tncm91bmQsIHdoaWNoIG1heSBub3QgYmUgZGVzaXJhYmxlLiBZb3Ugc2hvdWxkIGhvb2sgaW50byB5b3VyXG4gICAgICogcGxhdGZvcm0ncyBmb3JlZ3JvdW5kIGluZGljYXRpb24gbWVjaGFuaXNtIGFuZCBjYWxsIHRoZXNlIG1ldGhvZHNcbiAgICAgKiBhcHByb3ByaWF0ZWx5IHRvIGNvbnNlcnZlIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAgICovXG4gICAgYXN5bmMgc3RhcnRBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpO1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuIGFjdGl2ZSBhdXRvIHJlZnJlc2ggcHJvY2VzcyBydW5uaW5nIGluIHRoZSBiYWNrZ3JvdW5kIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWQgdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZVxuICAgICAqIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5IGNoYW5nZXMgb24geW91ciBvd24uXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rICNzdGFydEF1dG9SZWZyZXNofSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHN0b3BBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpO1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgYXV0byByZWZyZXNoIHRva2VuIHRpY2suXG4gICAgICovXG4gICAgYXN5bmMgX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5yZWZyZXNoX3Rva2VuIHx8ICFzZXNzaW9uLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdubyBzZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Vzc2lvbiB3aWxsIGV4cGlyZSBpbiB0aGlzIG1hbnkgdGlja3MgKG9yIGhhcyBhbHJlYWR5IGV4cGlyZWQgaWYgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmVzSW5UaWNrcyA9IE1hdGguZmxvb3IoKHNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBub3cpIC8gQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCBgYWNjZXNzIHRva2VuIGV4cGlyZXMgaW4gJHtleHBpcmVzSW5UaWNrc30gdGlja3MsIGEgdGljayBsYXN0cyAke0FVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TfW1zLCByZWZyZXNoIHRocmVzaG9sZCBpcyAke0FVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRH0gdGlja3NgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwaXJlc0luVGlja3MgPD0gQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oc2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQXV0byByZWZyZXNoIHRpY2sgZmFpbGVkIHdpdGggZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGEgdHJhbnNpZW50IGVycm9yLicsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ2VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5pc0FjcXVpcmVUaW1lb3V0IHx8IGUgaW5zdGFuY2VvZiBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdhdXRvIHJlZnJlc2ggdG9rZW4gdGljayBsb2NrIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBvbiB0aGUgYnJvd3NlciAvIHBsYXRmb3JtLCB3aGljaCBpbi10dXJuIHJ1blxuICAgICAqIGFsZ29yaXRobXMgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cvdGFiIGFyZSBpbiBmb3JlZ3JvdW5kLiBPbiBub24tYnJvd3NlclxuICAgICAqIHBsYXRmb3JtcyBpdCBhc3N1bWVzIGFsd2F5cyBmb3JlZ3JvdW5kLlxuICAgICAqL1xuICAgIGFzeW5jIF9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCknKTtcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSB8fCAhKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBhbHdheXNcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZChmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayk7XG4gICAgICAgICAgICAvLyBub3cgaW1tZWRpYXRlbHkgY2FsbCB0aGUgdmlzYmlsaXR5IGNoYW5nZWQgY2FsbGJhY2sgdG8gc2V0dXAgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgdmlzYmlsaXR5IHN0YXRlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKHRydWUpOyAvLyBpbml0aWFsIGNhbGxcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHJlZ2lzdGVyZWQgd2l0aCBgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnKWAuXG4gICAgICovXG4gICAgYXN5bmMgX29uVmlzaWJpbGl0eUNoYW5nZWQoY2FsbGVkRnJvbUluaXRpYWxpemUpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kTmFtZSA9IGAjX29uVmlzaWJpbGl0eUNoYW5nZWQoJHtjYWxsZWRGcm9tSW5pdGlhbGl6ZX0pYDtcbiAgICAgICAgdGhpcy5fZGVidWcobWV0aG9kTmFtZSwgJ3Zpc2liaWxpdHlTdGF0ZScsIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSk7XG4gICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGluIGJyb3dzZXIgZW52aXJvbm1lbnRzIHRoZSByZWZyZXNoIHRva2VuIHRpY2tlciBydW5zIG9ubHkgb24gZm9jdXNlZCB0YWJzXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggcHJldmVudHMgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYWxsZWRGcm9tSW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLCBpLmUuIHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNpdGlvbmVkIGZyb20gaGlkZGVuIC0+IHZpc2libGUgc28gd2UgbmVlZCB0byBzZWUgaWYgdGhlIHNlc3Npb25cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgcmVjb3ZlcmVkIGltbWVkaWF0ZWx5Li4uIGJ1dCB0byBkbyB0aGF0IHdlIG5lZWQgdG8gYWNxdWlyZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBsb2NrIGZpcnN0IGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICdhY3F1aXJlZCB0aGUgbG9jayB0byByZWNvdmVyIHRoZSBzZXNzaW9uLCBidXQgdGhlIGJyb3dzZXIgdmlzaWJpbGl0eVN0YXRlIGlzIG5vIGxvbmdlciB2aXNpYmxlLCBhYm9ydGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCB3aGlsZSB3YWl0aW5nIGZvciB0aGUgbG9jaywgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZWNvdmVyIHRoZSBzZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlY292ZXJBbmRSZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgcmVsZXZhbnQgbG9naW4gVVJMIGZvciBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gQSBVUkwgb3IgbW9iaWxlIGFkZHJlc3MgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGFyZSBjb25maXJtZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2NvcGVzIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2Ygc2NvcGVzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXJ5UGFyYW1zIEFuIG9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgY29udGFpbmluZyBxdWVyeSBwYXJhbWV0ZXJzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRVcmxGb3JQcm92aWRlcih1cmwsIHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IFtgcHJvdmlkZXI9JHtlbmNvZGVVUklDb21wb25lbnQocHJvdmlkZXIpfWBdO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0VG8pIHtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGByZWRpcmVjdF90bz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnJlZGlyZWN0VG8pfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NvcGVzKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgc2NvcGVzPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuc2NvcGVzKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICBjb25zdCBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGZsb3dQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2UpfWAsXG4gICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBgJHtlbmNvZGVVUklDb21wb25lbnQoY29kZUNoYWxsZW5nZU1ldGhvZCl9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goZmxvd1BhcmFtcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucy5xdWVyeVBhcmFtcyk7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChxdWVyeS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGBza2lwX2h0dHBfcmVkaXJlY3Q9JHtvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3R9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3VybH0/JHt1cmxQYXJhbXMuam9pbignJicpfWA7XG4gICAgfVxuICAgIGFzeW5jIF91bmVucm9sbChwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9lbnJvbGwocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKHsgZnJpZW5kbHlfbmFtZTogcGFyYW1zLmZyaWVuZGx5TmFtZSwgZmFjdG9yX3R5cGU6IHBhcmFtcy5mYWN0b3JUeXBlIH0sIChwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3Bob25lJyA/IHsgcGhvbmU6IHBhcmFtcy5waG9uZSB9IDogeyBpc3N1ZXI6IHBhcmFtcy5pc3N1ZXIgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnNgLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5mYWN0b3JUeXBlID09PSAndG90cCcgJiYgKChfYiA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS50b3RwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucXJfY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50b3RwLnFyX2NvZGUgPSBgZGF0YTppbWFnZS9zdmcreG1sO3V0Zi04LCR7ZGF0YS50b3RwLnFyX2NvZGV9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjdmVyaWZ5fVxuICAgICAqL1xuICAgIGFzeW5jIF92ZXJpZnkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vdmVyaWZ5YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogeyBjb2RlOiBwYXJhbXMuY29kZSwgY2hhbGxlbmdlX2lkOiBwYXJhbXMuY2hhbGxlbmdlSWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oT2JqZWN0LmFzc2lnbih7IGV4cGlyZXNfYXQ6IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApICsgZGF0YS5leHBpcmVzX2luIH0sIGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ01GQV9DSEFMTEVOR0VfVkVSSUZJRUQnLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjY2hhbGxlbmdlfVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGFsbGVuZ2UocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9L2NoYWxsZW5nZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgY2hhbm5lbDogcGFyYW1zLmNoYW5uZWwgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNjaGFsbGVuZ2VBbmRWZXJpZnl9XG4gICAgICovXG4gICAgYXN5bmMgX2NoYWxsZW5nZUFuZFZlcmlmeShwYXJhbXMpIHtcbiAgICAgICAgLy8gYm90aCBfY2hhbGxlbmdlIGFuZCBfdmVyaWZ5IGluZGVwZW5kZW50bHkgYWNxdWlyZSB0aGUgbG9jaywgc28gbm8gbmVlZFxuICAgICAgICAvLyB0byBhY3F1aXJlIGl0IGhlcmVcbiAgICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VEYXRhLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NoYWxsZW5nZSh7XG4gICAgICAgICAgICBmYWN0b3JJZDogcGFyYW1zLmZhY3RvcklkLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNoYWxsZW5nZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdmVyaWZ5KHtcbiAgICAgICAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlRGF0YS5pZCxcbiAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2xpc3RGYWN0b3JzfVxuICAgICAqL1xuICAgIGFzeW5jIF9saXN0RmFjdG9ycygpIHtcbiAgICAgICAgLy8gdXNlICNnZXRVc2VyIGluc3RlYWQgb2YgI19nZXRVc2VyIGFzIHRoZSBmb3JtZXIgYWNxdWlyZXMgYSBsb2NrXG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiB1c2VyRXJyb3IsIH0gPSBhd2FpdCB0aGlzLmdldFVzZXIoKTtcbiAgICAgICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHVzZXJFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY3RvcnMgPSAodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLmZhY3RvcnMpIHx8IFtdO1xuICAgICAgICBjb25zdCB0b3RwID0gZmFjdG9ycy5maWx0ZXIoKGZhY3RvcikgPT4gZmFjdG9yLmZhY3Rvcl90eXBlID09PSAndG90cCcgJiYgZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJyk7XG4gICAgICAgIGNvbnN0IHBob25lID0gZmFjdG9ycy5maWx0ZXIoKGZhY3RvcikgPT4gZmFjdG9yLmZhY3Rvcl90eXBlID09PSAncGhvbmUnICYmIGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGFsbDogZmFjdG9ycyxcbiAgICAgICAgICAgICAgICB0b3RwLFxuICAgICAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsfVxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IGN1cnJlbnRMZXZlbDogbnVsbCwgbmV4dExldmVsOiBudWxsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gZGVjb2RlSldUKHNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5hYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExldmVsID0gcGF5bG9hZC5hYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXh0TGV2ZWwgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyaWZpZWRGYWN0b3JzID0gKF9iID0gKF9hID0gc2Vzc2lvbi51c2VyLmZhY3RvcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoKGZhY3RvcikgPT4gZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0TGV2ZWwgPSAnYWFsMic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGN1cnJlbnRMZXZlbCwgbmV4dExldmVsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoSndrKGtpZCwgandrcyA9IHsga2V5czogW10gfSkge1xuICAgICAgICAvLyB0cnkgZmV0Y2hpbmcgZnJvbSB0aGUgc3VwcGxpZWQgandrc1xuICAgICAgICBsZXQgandrID0gandrcy5rZXlzLmZpbmQoKGtleSkgPT4ga2V5LmtpZCA9PT0ga2lkKTtcbiAgICAgICAgaWYgKGp3aykge1xuICAgICAgICAgICAgcmV0dXJuIGp3aztcbiAgICAgICAgfVxuICAgICAgICAvLyB0cnkgZmV0Y2hpbmcgZnJvbSBjYWNoZVxuICAgICAgICBqd2sgPSB0aGlzLmp3a3Mua2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZCk7XG4gICAgICAgIC8vIGp3ayBleGlzdHMgYW5kIGp3a3MgaXNuJ3Qgc3RhbGVcbiAgICAgICAgaWYgKGp3ayAmJiB0aGlzLmp3a3NfY2FjaGVkX2F0ICsgSldLU19UVEwgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICByZXR1cm4gandrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGp3ayBpc24ndCBjYWNoZWQgaW4gbWVtb3J5IHNvIHdlIG5lZWQgdG8gZmV0Y2ggaXQgZnJvbSB0aGUgd2VsbC1rbm93biBlbmRwb2ludFxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9Ly53ZWxsLWtub3duL2p3a3MuanNvbmAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmtleXMgfHwgZGF0YS5rZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0pXS1MgaXMgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmp3a3MgPSBkYXRhO1xuICAgICAgICB0aGlzLmp3a3NfY2FjaGVkX2F0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gRmluZCB0aGUgc2lnbmluZyBrZXlcbiAgICAgICAgandrID0gZGF0YS5rZXlzLmZpbmQoKGtleSkgPT4ga2V5LmtpZCA9PT0ga2lkKTtcbiAgICAgICAgaWYgKCFqd2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZEp3dEVycm9yKCdObyBtYXRjaGluZyBzaWduaW5nIGtleSBmb3VuZCBpbiBKV0tTJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGp3aztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0cyB0aGUgY2xhaW1zIGZyb20gYSBKV1QuIElmIHRoZSBKV1QgaXMgc3ltbWV0cmljIEpXVHMsIGl0IHdpbGwgY2FsbCBnZXRVc2VyKCkgdG8gdmVyaWZ5IGFnYWluc3QgdGhlIHNlcnZlci4gSWYgdGhlIEpXVCBpcyBhc3ltbWV0cmljLCBpdCB3aWxsIGJlIHZlcmlmaWVkIGFnYWluc3QgdGhlIEpXS1MgdXNpbmcgdGhlIFdlYkNyeXB0byBBUEkuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q2xhaW1zKGp3dCwgandrcyA9IHsga2V5czogW10gfSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRva2VuID0gand0O1xuICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuID0gZGF0YS5zZXNzaW9uLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgaGVhZGVyLCBwYXlsb2FkLCBzaWduYXR1cmUsIHJhdzogeyBoZWFkZXI6IHJhd0hlYWRlciwgcGF5bG9hZDogcmF3UGF5bG9hZCB9LCB9ID0gZGVjb2RlSldUKHRva2VuKTtcbiAgICAgICAgICAgIC8vIFJlamVjdCBleHBpcmVkIEpXVHNcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwKHBheWxvYWQuZXhwKTtcbiAgICAgICAgICAgIC8vIElmIHN5bW1ldHJpYyBhbGdvcml0aG0gb3IgV2ViQ3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gZ2V0VXNlcigpXG4gICAgICAgICAgICBpZiAoIWhlYWRlci5raWQgfHxcbiAgICAgICAgICAgICAgICBoZWFkZXIuYWxnID09PSAnSFMyNTYnIHx8XG4gICAgICAgICAgICAgICAgISgnY3J5cHRvJyBpbiBnbG9iYWxUaGlzICYmICdzdWJ0bGUnIGluIGdsb2JhbFRoaXMuY3J5cHRvKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcih0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnZXRVc2VyIHN1Y2NlZWRzIHNvIHRoZSBjbGFpbXMgaW4gdGhlIEpXVCBjYW4gYmUgdHJ1c3RlZFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYWltczogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IGdldEFsZ29yaXRobShoZWFkZXIuYWxnKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBhd2FpdCB0aGlzLmZldGNoSndrKGhlYWRlci5raWQsIGp3a3MpO1xuICAgICAgICAgICAgLy8gQ29udmVydCBKV0sgdG8gQ3J5cHRvS2V5XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgnandrJywgc2lnbmluZ0tleSwgYWxnb3JpdGhtLCB0cnVlLCBbXG4gICAgICAgICAgICAgICAgJ3ZlcmlmeScsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgc2lnbmF0dXJlXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS52ZXJpZnkoYWxnb3JpdGhtLCBwdWJsaWNLZXksIHNpZ25hdHVyZSwgc3RyaW5nVG9VaW50OEFycmF5KGAke3Jhd0hlYWRlcn0uJHtyYXdQYXlsb2FkfWApKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZEp3dEVycm9yKCdJbnZhbGlkIEpXVCBzaWduYXR1cmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHZlcmlmaWNhdGlvbiBzdWNjZWVkcywgZGVjb2RlIGFuZCByZXR1cm4gY2xhaW1zXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhaW1zOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5Hb1RydWVDbGllbnQubmV4dEluc3RhbmNlSUQgPSAwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R29UcnVlQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJHb1RydWVBZG1pbkFwaSIsIkRFRkFVTFRfSEVBREVSUyIsIkVYUElSWV9NQVJHSU5fTVMiLCJBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUyIsIkFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCIsIkdPVFJVRV9VUkwiLCJTVE9SQUdFX0tFWSIsIkpXS1NfVFRMIiwiQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIiwiQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIiwiQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IiLCJBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciIsIkF1dGhVbmtub3duRXJyb3IiLCJpc0F1dGhBcGlFcnJvciIsImlzQXV0aEVycm9yIiwiaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciIsImlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IiLCJpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsIkF1dGhJbnZhbGlkSnd0RXJyb3IiLCJfcmVxdWVzdCIsIl9zZXNzaW9uUmVzcG9uc2UiLCJfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQiLCJfdXNlclJlc3BvbnNlIiwiX3Nzb1Jlc3BvbnNlIiwiRGVmZXJyZWQiLCJnZXRJdGVtQXN5bmMiLCJpc0Jyb3dzZXIiLCJyZW1vdmVJdGVtQXN5bmMiLCJyZXNvbHZlRmV0Y2giLCJzZXRJdGVtQXN5bmMiLCJ1dWlkIiwicmV0cnlhYmxlIiwic2xlZXAiLCJzdXBwb3J0c0xvY2FsU3RvcmFnZSIsInBhcnNlUGFyYW1ldGVyc0Zyb21VUkwiLCJnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kIiwiZ2V0QWxnb3JpdGhtIiwidmFsaWRhdGVFeHAiLCJkZWNvZGVKV1QiLCJsb2NhbFN0b3JhZ2VBZGFwdGVyIiwibWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciIsInBvbHlmaWxsR2xvYmFsVGhpcyIsInZlcnNpb24iLCJMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciIsIm5hdmlnYXRvckxvY2siLCJzdHJpbmdUb1VpbnQ4QXJyYXkiLCJERUZBVUxUX09QVElPTlMiLCJ1cmwiLCJzdG9yYWdlS2V5IiwiYXV0b1JlZnJlc2hUb2tlbiIsInBlcnNpc3RTZXNzaW9uIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwiaGVhZGVycyIsImZsb3dUeXBlIiwiZGVidWciLCJoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyIiwibG9ja05vT3AiLCJuYW1lIiwiYWNxdWlyZVRpbWVvdXQiLCJmbiIsIkdvVHJ1ZUNsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIl9hIiwiX2IiLCJtZW1vcnlTdG9yYWdlIiwic3RhdGVDaGFuZ2VFbWl0dGVycyIsIk1hcCIsImF1dG9SZWZyZXNoVGlja2VyIiwidmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayIsInJlZnJlc2hpbmdEZWZlcnJlZCIsImluaXRpYWxpemVQcm9taXNlIiwic3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyIsImxvY2tBY3F1aXJlZCIsInBlbmRpbmdJbkxvY2siLCJicm9hZGNhc3RDaGFubmVsIiwibG9nZ2VyIiwiY29uc29sZSIsImxvZyIsImluc3RhbmNlSUQiLCJuZXh0SW5zdGFuY2VJRCIsIndhcm4iLCJzZXR0aW5ncyIsIk9iamVjdCIsImFzc2lnbiIsImxvZ0RlYnVnTWVzc2FnZXMiLCJhZG1pbiIsImZldGNoIiwibG9jayIsImdsb2JhbFRoaXMiLCJuYXZpZ2F0b3IiLCJsb2NrcyIsImp3a3MiLCJrZXlzIiwiandrc19jYWNoZWRfYXQiLCJOdW1iZXIiLCJNSU5fU0FGRV9JTlRFR0VSIiwibWZhIiwidmVyaWZ5IiwiX3ZlcmlmeSIsImJpbmQiLCJlbnJvbGwiLCJfZW5yb2xsIiwidW5lbnJvbGwiLCJfdW5lbnJvbGwiLCJjaGFsbGVuZ2UiLCJfY2hhbGxlbmdlIiwibGlzdEZhY3RvcnMiLCJfbGlzdEZhY3RvcnMiLCJjaGFsbGVuZ2VBbmRWZXJpZnkiLCJfY2hhbGxlbmdlQW5kVmVyaWZ5IiwiZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsIiwiX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbCIsInN0b3JhZ2UiLCJCcm9hZGNhc3RDaGFubmVsIiwiZSIsImVycm9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiX2RlYnVnIiwiX25vdGlmeUFsbFN1YnNjcmliZXJzIiwiZGF0YSIsInNlc3Npb24iLCJpbml0aWFsaXplIiwiYXJncyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIl9hY3F1aXJlTG9jayIsIl9pbml0aWFsaXplIiwicGFyYW1zIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiY2FsbGJhY2tVcmxUeXBlIiwiX2lzSW1wbGljaXRHcmFudENhbGxiYWNrIiwiX2lzUEtDRUNhbGxiYWNrIiwiX2dldFNlc3Npb25Gcm9tVVJMIiwiZXJyb3JDb2RlIiwiZGV0YWlscyIsImNvZGUiLCJfcmVtb3ZlU2Vzc2lvbiIsInJlZGlyZWN0VHlwZSIsIl9zYXZlU2Vzc2lvbiIsInNldFRpbWVvdXQiLCJfcmVjb3ZlckFuZFJlZnJlc2giLCJfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsInNpZ25JbkFub255bW91c2x5IiwiY3JlZGVudGlhbHMiLCJfYyIsInJlcyIsImJvZHkiLCJnb3RydWVfbWV0YV9zZWN1cml0eSIsImNhcHRjaGFfdG9rZW4iLCJjYXB0Y2hhVG9rZW4iLCJ4Zm9ybSIsInVzZXIiLCJzaWduVXAiLCJlbWFpbCIsInBhc3N3b3JkIiwiY29kZUNoYWxsZW5nZSIsImNvZGVDaGFsbGVuZ2VNZXRob2QiLCJyZWRpcmVjdFRvIiwiZW1haWxSZWRpcmVjdFRvIiwiY29kZV9jaGFsbGVuZ2UiLCJjb2RlX2NoYWxsZW5nZV9tZXRob2QiLCJwaG9uZSIsImNoYW5uZWwiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJ3ZWFrX3Bhc3N3b3JkIiwid2Vha1Bhc3N3b3JkIiwic2lnbkluV2l0aE9BdXRoIiwiX2QiLCJfaGFuZGxlUHJvdmlkZXJTaWduSW4iLCJwcm92aWRlciIsInNjb3BlcyIsInF1ZXJ5UGFyYW1zIiwic2tpcEJyb3dzZXJSZWRpcmVjdCIsImV4Y2hhbmdlQ29kZUZvclNlc3Npb24iLCJhdXRoQ29kZSIsIl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uIiwic3RvcmFnZUl0ZW0iLCJjb2RlVmVyaWZpZXIiLCJzcGxpdCIsImF1dGhfY29kZSIsImNvZGVfdmVyaWZpZXIiLCJzaWduSW5XaXRoSWRUb2tlbiIsInRva2VuIiwiYWNjZXNzX3Rva2VuIiwibm9uY2UiLCJpZF90b2tlbiIsInNpZ25JbldpdGhPdHAiLCJfZSIsImNyZWF0ZV91c2VyIiwic2hvdWxkQ3JlYXRlVXNlciIsIm1lc3NhZ2VJZCIsIm1lc3NhZ2VfaWQiLCJ2ZXJpZnlPdHAiLCJ1bmRlZmluZWQiLCJFcnJvciIsInR5cGUiLCJzaWduSW5XaXRoU1NPIiwicHJvdmlkZXJfaWQiLCJwcm92aWRlcklkIiwiZG9tYWluIiwicmVkaXJlY3RfdG8iLCJza2lwX2h0dHBfcmVkaXJlY3QiLCJyZWF1dGhlbnRpY2F0ZSIsIl9yZWF1dGhlbnRpY2F0ZSIsIl91c2VTZXNzaW9uIiwicmVzdWx0Iiwic2Vzc2lvbkVycm9yIiwiand0IiwicmVzZW5kIiwiZW5kcG9pbnQiLCJnZXRTZXNzaW9uIiwibGFzdCIsImxlbmd0aCIsIlByb21pc2UiLCJyZXNvbHZlIiwicHVzaCIsIndhaXRPbiIsImFsbCIsInNwbGljZSIsIl9fbG9hZFNlc3Npb24iLCJzdGFjayIsImN1cnJlbnRTZXNzaW9uIiwibWF5YmVTZXNzaW9uIiwiX2lzVmFsaWRTZXNzaW9uIiwiaGFzRXhwaXJlZCIsImV4cGlyZXNfYXQiLCJub3ciLCJpc1NlcnZlciIsInN1cHByZXNzV2FybmluZyIsInByb3h5U2Vzc2lvbiIsIlByb3h5IiwiZ2V0IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsIl9jYWxsUmVmcmVzaFRva2VuIiwicmVmcmVzaF90b2tlbiIsImdldFVzZXIiLCJfZ2V0VXNlciIsInVwZGF0ZVVzZXIiLCJhdHRyaWJ1dGVzIiwiX3VwZGF0ZVVzZXIiLCJzZXNzaW9uRGF0YSIsInVzZXJFcnJvciIsInNldFNlc3Npb24iLCJfc2V0U2Vzc2lvbiIsInRpbWVOb3ciLCJleHBpcmVzQXQiLCJwYXlsb2FkIiwiZXhwIiwicmVmcmVzaGVkU2Vzc2lvbiIsInRva2VuX3R5cGUiLCJleHBpcmVzX2luIiwicmVmcmVzaFNlc3Npb24iLCJfcmVmcmVzaFNlc3Npb24iLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yX2NvZGUiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJkZWxldGUiLCJoaXN0b3J5IiwicmVwbGFjZVN0YXRlIiwic3RhdGUiLCJ0b1N0cmluZyIsInByb3ZpZGVyX3Rva2VuIiwicHJvdmlkZXJfcmVmcmVzaF90b2tlbiIsIk1hdGgiLCJyb3VuZCIsImV4cGlyZXNJbiIsInBhcnNlSW50IiwiYWN0dWFsbHlFeHBpcmVzSW4iLCJpc3N1ZWRBdCIsImhhc2giLCJCb29sZWFuIiwiY3VycmVudFN0b3JhZ2VDb250ZW50Iiwic2lnbk91dCIsInNjb3BlIiwiX3NpZ25PdXQiLCJhY2Nlc3NUb2tlbiIsInN0YXR1cyIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwiY2FsbGJhY2siLCJpZCIsInN1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlIiwic2V0IiwiX2VtaXRJbml0aWFsU2Vzc2lvbiIsImVyciIsInJlc2V0UGFzc3dvcmRGb3JFbWFpbCIsImdldFVzZXJJZGVudGl0aWVzIiwiaWRlbnRpdGllcyIsImxpbmtJZGVudGl0eSIsIl9nZXRVcmxGb3JQcm92aWRlciIsInVubGlua0lkZW50aXR5IiwiaWRlbnRpdHkiLCJpZGVudGl0eV9pZCIsIl9yZWZyZXNoQWNjZXNzVG9rZW4iLCJyZWZyZXNoVG9rZW4iLCJkZWJ1Z05hbWUiLCJzdWJzdHJpbmciLCJzdGFydGVkQXQiLCJhdHRlbXB0IiwicG93IiwibmV4dEJhY2tPZmZJbnRlcnZhbCIsImlzVmFsaWRTZXNzaW9uIiwiZXhwaXJlc1dpdGhNYXJnaW4iLCJJbmZpbml0eSIsInByb21pc2UiLCJyZWplY3QiLCJicm9hZGNhc3QiLCJwb3N0TWVzc2FnZSIsImVycm9ycyIsInByb21pc2VzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwibWFwIiwieCIsImkiLCJfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfc3RhcnRBdXRvUmVmcmVzaCIsIl9zdG9wQXV0b1JlZnJlc2giLCJ0aWNrZXIiLCJzZXRJbnRlcnZhbCIsIl9hdXRvUmVmcmVzaFRva2VuVGljayIsInVucmVmIiwiRGVubyIsInVucmVmVGltZXIiLCJjbGVhckludGVydmFsIiwic3RhcnRBdXRvUmVmcmVzaCIsInN0b3BBdXRvUmVmcmVzaCIsImV4cGlyZXNJblRpY2tzIiwiZmxvb3IiLCJpc0FjcXVpcmVUaW1lb3V0IiwiX29uVmlzaWJpbGl0eUNoYW5nZWQiLCJjYWxsZWRGcm9tSW5pdGlhbGl6ZSIsIm1ldGhvZE5hbWUiLCJkb2N1bWVudCIsInZpc2liaWxpdHlTdGF0ZSIsInVybFBhcmFtcyIsImVuY29kZVVSSUNvbXBvbmVudCIsImZsb3dQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJxdWVyeSIsImpvaW4iLCJmYWN0b3JJZCIsImZyaWVuZGx5X25hbWUiLCJmcmllbmRseU5hbWUiLCJmYWN0b3JfdHlwZSIsImZhY3RvclR5cGUiLCJpc3N1ZXIiLCJ0b3RwIiwicXJfY29kZSIsImNoYWxsZW5nZV9pZCIsImNoYWxsZW5nZUlkIiwiY2hhbGxlbmdlRGF0YSIsImNoYWxsZW5nZUVycm9yIiwiZmFjdG9ycyIsImZpbHRlciIsImZhY3RvciIsImN1cnJlbnRMZXZlbCIsIm5leHRMZXZlbCIsImN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMiLCJhYWwiLCJ2ZXJpZmllZEZhY3RvcnMiLCJhbXIiLCJmZXRjaEp3ayIsImtpZCIsImp3ayIsImZpbmQiLCJrZXkiLCJnZXRDbGFpbXMiLCJoZWFkZXIiLCJzaWduYXR1cmUiLCJyYXciLCJyYXdIZWFkZXIiLCJyYXdQYXlsb2FkIiwiYWxnIiwiY3J5cHRvIiwiY2xhaW1zIiwiYWxnb3JpdGhtIiwic2lnbmluZ0tleSIsInB1YmxpY0tleSIsInN1YnRsZSIsImltcG9ydEtleSIsImlzVmFsaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/index.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/index.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _AuthClient__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   AuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.CustomAuthError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.internals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GoTrueClient */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n/* harmony import */ var _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthAdminApi */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\");\n/* harmony import */ var _AuthClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthClient */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/AuthClient.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/types */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/errors */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDSjtBQUNBO0FBQ0o7QUFDNEI7QUFDdEM7QUFDQztBQUM4RSxDQUMzRyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvaW5kZXguanM/MTAwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSc7XG5pbXBvcnQgR29UcnVlQ2xpZW50IGZyb20gJy4vR29UcnVlQ2xpZW50JztcbmltcG9ydCBBdXRoQWRtaW5BcGkgZnJvbSAnLi9BdXRoQWRtaW5BcGknO1xuaW1wb3J0IEF1dGhDbGllbnQgZnJvbSAnLi9BdXRoQ2xpZW50JztcbmV4cG9ydCB7IEdvVHJ1ZUFkbWluQXBpLCBHb1RydWVDbGllbnQsIEF1dGhBZG1pbkFwaSwgQXV0aENsaWVudCB9O1xuZXhwb3J0ICogZnJvbSAnLi9saWIvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZXJyb3JzJztcbmV4cG9ydCB7IG5hdmlnYXRvckxvY2ssIE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yLCBpbnRlcm5hbHMgYXMgbG9ja0ludGVybmFscywgfSBmcm9tICcuL2xpYi9sb2Nrcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiR29UcnVlQWRtaW5BcGkiLCJHb1RydWVDbGllbnQiLCJBdXRoQWRtaW5BcGkiLCJBdXRoQ2xpZW50IiwibmF2aWdhdG9yTG9jayIsIk5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIiwiaW50ZXJuYWxzIiwibG9ja0ludGVybmFscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/index.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/base64url.js":
/*!************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/base64url.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64UrlToUint8Array: () => (/* binding */ base64UrlToUint8Array),\n/* harmony export */   byteFromBase64URL: () => (/* binding */ byteFromBase64URL),\n/* harmony export */   byteToBase64URL: () => (/* binding */ byteToBase64URL),\n/* harmony export */   codepointToUTF8: () => (/* binding */ codepointToUTF8),\n/* harmony export */   stringFromBase64URL: () => (/* binding */ stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* binding */ stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* binding */ stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* binding */ stringToUTF8),\n/* harmony export */   stringToUint8Array: () => (/* binding */ stringToUint8Array)\n/* harmony export */ });\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */ /**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */ const TO_BASE64URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\");\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */ const IGNORE_BASE64URL = \" \t\\n\\r=\".split(\"\");\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */ const FROM_BASE64URL = (()=>{\n    const charMap = new Array(128);\n    for(let i = 0; i < charMap.length; i += 1){\n        charMap[i] = -1;\n    }\n    for(let i = 0; i < IGNORE_BASE64URL.length; i += 1){\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for(let i = 0; i < TO_BASE64URL.length; i += 1){\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */ function byteToBase64URL(byte, state, emit) {\n    if (byte !== null) {\n        state.queue = state.queue << 8 | byte;\n        state.queuedBits += 8;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    } else if (state.queuedBits > 0) {\n        state.queue = state.queue << 6 - state.queuedBits;\n        state.queuedBits = 6;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */ function byteFromBase64URL(charCode, state, emit) {\n    const bits = FROM_BASE64URL[charCode];\n    if (bits > -1) {\n        // valid Base64-URL character\n        state.queue = state.queue << 6 | bits;\n        state.queuedBits += 6;\n        while(state.queuedBits >= 8){\n            emit(state.queue >> state.queuedBits - 8 & 0xff);\n            state.queuedBits -= 8;\n        }\n    } else if (bits === -2) {\n        // ignore spaces, tabs, newlines, =\n        return;\n    } else {\n        throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n    }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */ function stringToBase64URL(str) {\n    const base64 = [];\n    const emitter = (char)=>{\n        base64.push(char);\n    };\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    stringToUTF8(str, (byte)=>{\n        byteToBase64URL(byte, state, emitter);\n    });\n    byteToBase64URL(null, state, emitter);\n    return base64.join(\"\");\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */ function stringFromBase64URL(str) {\n    const conv = [];\n    const utf8Emit = (codepoint)=>{\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const utf8State = {\n        utf8seq: 0,\n        codepoint: 0\n    };\n    const b64State = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const byteEmit = (byte)=>{\n        stringFromUTF8(byte, utf8State, utf8Emit);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n    }\n    return conv.join(\"\");\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */ function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    } else if (codepoint <= 0x7ff) {\n        emit(0xc0 | codepoint >> 6);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0xffff) {\n        emit(0xe0 | codepoint >> 12);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | codepoint >> 18);\n        emit(0x80 | codepoint >> 12 & 0x3f);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */ function stringToUTF8(str, emit) {\n    for(let i = 0; i < str.length; i += 1){\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n            const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */ function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for(let leadingBit = 1; leadingBit < 6; leadingBit += 1){\n            if ((byte >> 7 - leadingBit & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        } else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        } else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        } else {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.utf8seq -= 1;\n    } else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.codepoint = state.codepoint << 6 | byte & 63;\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */ function base64UrlToUint8Array(str) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onByte = (byte)=>{\n        result.push(byte);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\n    }\n    return new Uint8Array(result);\n}\nfunction stringToUint8Array(str) {\n    const result = [];\n    stringToUTF8(str, (byte)=>result.push(byte));\n    return new Uint8Array(result);\n} //# sourceMappingURL=base64url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Jhc2U2NHVybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0Q7OztDQUdDLEdBQ0QsTUFBTUEsZUFBZSxtRUFBbUVDLEtBQUssQ0FBQztBQUM5Rjs7O0NBR0MsR0FDRCxNQUFNQyxtQkFBbUIsVUFBV0QsS0FBSyxDQUFDO0FBQzFDOzs7Q0FHQyxHQUNELE1BQU1FLGlCQUFpQixDQUFDO0lBQ3BCLE1BQU1DLFVBQVUsSUFBSUMsTUFBTTtJQUMxQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsUUFBUUcsTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDeENGLE9BQU8sQ0FBQ0UsRUFBRSxHQUFHLENBQUM7SUFDbEI7SUFDQSxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSUosaUJBQWlCSyxNQUFNLEVBQUVELEtBQUssRUFBRztRQUNqREYsT0FBTyxDQUFDRixnQkFBZ0IsQ0FBQ0ksRUFBRSxDQUFDRSxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDbEQ7SUFDQSxJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSU4sYUFBYU8sTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDN0NGLE9BQU8sQ0FBQ0osWUFBWSxDQUFDTSxFQUFFLENBQUNFLFVBQVUsQ0FBQyxHQUFHLEdBQUdGO0lBQzdDO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNLLGdCQUFnQkMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLElBQUk7SUFDN0MsSUFBSUYsU0FBUyxNQUFNO1FBQ2ZDLE1BQU1FLEtBQUssR0FBRyxNQUFPQSxLQUFLLElBQUksSUFBS0g7UUFDbkNDLE1BQU1HLFVBQVUsSUFBSTtRQUNwQixNQUFPSCxNQUFNRyxVQUFVLElBQUksRUFBRztZQUMx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LE9BQVNvQyxPQUFPbkIsSUFBSSxDQUFDakI7SUFDeEMsT0FBTyxJQUFJc0MsV0FBV0Y7QUFDMUIsRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Jhc2U2NHVybC5qcz9iMmRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXZvaWQgbW9kaWZ5aW5nIHRoaXMgZmlsZS4gSXQncyBwYXJ0IG9mXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UtY29tbXVuaXR5L2Jhc2U2NHVybC1qcy4gIFN1Ym1pdCBhbGwgZml4ZXMgb25cbiAqIHRoYXQgcmVwbyFcbiAqL1xuLyoqXG4gKiBBbiBhcnJheSBvZiBjaGFyYWN0ZXJzIHRoYXQgZW5jb2RlIDYgYml0cyBpbnRvIGEgQmFzZTY0LVVSTCBhbHBoYWJldFxuICogY2hhcmFjdGVyLlxuICovXG5jb25zdCBUT19CQVNFNjRVUkwgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycuc3BsaXQoJycpO1xuLyoqXG4gKiBBbiBhcnJheSBvZiBjaGFyYWN0ZXJzIHRoYXQgY2FuIGFwcGVhciBpbiBhIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcgYnV0XG4gKiBzaG91bGQgYmUgaWdub3JlZC5cbiAqL1xuY29uc3QgSUdOT1JFX0JBU0U2NFVSTCA9ICcgXFx0XFxuXFxyPScuc3BsaXQoJycpO1xuLyoqXG4gKiBBbiBhcnJheSBvZiAxMjggbnVtYmVycyB0aGF0IG1hcCBhIEJhc2U2NC1VUkwgY2hhcmFjdGVyIHRvIDYgYml0cywgb3IgaWYgLTJcbiAqIHVzZWQgdG8gc2tpcCB0aGUgY2hhcmFjdGVyLCBvciBpZiAtMSB1c2VkIHRvIGVycm9yIG91dC5cbiAqL1xuY29uc3QgRlJPTV9CQVNFNjRVUkwgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGNoYXJNYXAgPSBuZXcgQXJyYXkoMTI4KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJNYXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY2hhck1hcFtpXSA9IC0xO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IElHTk9SRV9CQVNFNjRVUkwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY2hhck1hcFtJR05PUkVfQkFTRTY0VVJMW2ldLmNoYXJDb2RlQXQoMCldID0gLTI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVE9fQkFTRTY0VVJMLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbVE9fQkFTRTY0VVJMW2ldLmNoYXJDb2RlQXQoMCldID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJNYXA7XG59KSgpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGJ5dGUgdG8gYSBCYXNlNjQtVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYnl0ZSBUaGUgYnl0ZSB0byBjb252ZXJ0LCBvciBudWxsIHRvIGZsdXNoIGF0IHRoZSBlbmQgb2YgdGhlIGJ5dGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIEJhc2U2NCBjb252ZXJzaW9uIHN0YXRlLiBQYXNzIGFuIGluaXRpYWwgdmFsdWUgb2YgYHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfWAuXG4gKiBAcGFyYW0gZW1pdCBBIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBuZXh0IEJhc2U2NCBjaGFyYWN0ZXIgd2hlbiByZWFkeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVUb0Jhc2U2NFVSTChieXRlLCBzdGF0ZSwgZW1pdCkge1xuICAgIGlmIChieXRlICE9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLnF1ZXVlID0gKHN0YXRlLnF1ZXVlIDw8IDgpIHwgYnl0ZTtcbiAgICAgICAgc3RhdGUucXVldWVkQml0cyArPSA4O1xuICAgICAgICB3aGlsZSAoc3RhdGUucXVldWVkQml0cyA+PSA2KSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSAoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA2KSkgJiA2MztcbiAgICAgICAgICAgIGVtaXQoVE9fQkFTRTY0VVJMW3Bvc10pO1xuICAgICAgICAgICAgc3RhdGUucXVldWVkQml0cyAtPSA2O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlLnF1ZXVlZEJpdHMgPiAwKSB7XG4gICAgICAgIHN0YXRlLnF1ZXVlID0gc3RhdGUucXVldWUgPDwgKDYgLSBzdGF0ZS5xdWV1ZWRCaXRzKTtcbiAgICAgICAgc3RhdGUucXVldWVkQml0cyA9IDY7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5xdWV1ZWRCaXRzID49IDYpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IChzdGF0ZS5xdWV1ZSA+PiAoc3RhdGUucXVldWVkQml0cyAtIDYpKSAmIDYzO1xuICAgICAgICAgICAgZW1pdChUT19CQVNFNjRVUkxbcG9zXSk7XG4gICAgICAgICAgICBzdGF0ZS5xdWV1ZWRCaXRzIC09IDY7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgU3RyaW5nIGNoYXIgY29kZSAoZXh0cmFjdGVkIHVzaW5nIGBzdHJpbmcuY2hhckNvZGVBdChwb3NpdGlvbilgKSB0byBhIHNlcXVlbmNlIG9mIEJhc2U2NC1VUkwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gY2hhckNvZGUgVGhlIGNoYXIgY29kZSBvZiB0aGUgSmF2YVNjcmlwdCBzdHJpbmcuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIEJhc2U2NCBzdGF0ZS4gUGFzcyBhbiBpbml0aWFsIHZhbHVlIG9mIGB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH1gLlxuICogQHBhcmFtIGVtaXQgQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZUZyb21CYXNlNjRVUkwoY2hhckNvZGUsIHN0YXRlLCBlbWl0KSB7XG4gICAgY29uc3QgYml0cyA9IEZST01fQkFTRTY0VVJMW2NoYXJDb2RlXTtcbiAgICBpZiAoYml0cyA+IC0xKSB7XG4gICAgICAgIC8vIHZhbGlkIEJhc2U2NC1VUkwgY2hhcmFjdGVyXG4gICAgICAgIHN0YXRlLnF1ZXVlID0gKHN0YXRlLnF1ZXVlIDw8IDYpIHwgYml0cztcbiAgICAgICAgc3RhdGUucXVldWVkQml0cyArPSA2O1xuICAgICAgICB3aGlsZSAoc3RhdGUucXVldWVkQml0cyA+PSA4KSB7XG4gICAgICAgICAgICBlbWl0KChzdGF0ZS5xdWV1ZSA+PiAoc3RhdGUucXVldWVkQml0cyAtIDgpKSAmIDB4ZmYpO1xuICAgICAgICAgICAgc3RhdGUucXVldWVkQml0cyAtPSA4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpdHMgPT09IC0yKSB7XG4gICAgICAgIC8vIGlnbm9yZSBzcGFjZXMsIHRhYnMsIG5ld2xpbmVzLCA9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBCYXNlNjQtVVJMIGNoYXJhY3RlciBcIiR7U3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSl9XCJgKTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgSmF2YVNjcmlwdCBzdHJpbmcgKHdoaWNoIG1heSBpbmNsdWRlIGFueSB2YWxpZCBjaGFyYWN0ZXIpIGludG8gYVxuICogQmFzZTY0LVVSTCBlbmNvZGVkIHN0cmluZy4gVGhlIHN0cmluZyBpcyBmaXJzdCBlbmNvZGVkIGluIFVURi04IHdoaWNoIGlzXG4gKiB0aGVuIGVuY29kZWQgYXMgQmFzZTY0LVVSTC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvQmFzZTY0VVJMKHN0cikge1xuICAgIGNvbnN0IGJhc2U2NCA9IFtdO1xuICAgIGNvbnN0IGVtaXR0ZXIgPSAoY2hhcikgPT4ge1xuICAgICAgICBiYXNlNjQucHVzaChjaGFyKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRlID0geyBxdWV1ZTogMCwgcXVldWVkQml0czogMCB9O1xuICAgIHN0cmluZ1RvVVRGOChzdHIsIChieXRlKSA9PiB7XG4gICAgICAgIGJ5dGVUb0Jhc2U2NFVSTChieXRlLCBzdGF0ZSwgZW1pdHRlcik7XG4gICAgfSk7XG4gICAgYnl0ZVRvQmFzZTY0VVJMKG51bGwsIHN0YXRlLCBlbWl0dGVyKTtcbiAgICByZXR1cm4gYmFzZTY0LmpvaW4oJycpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcgaW50byBhIEphdmFTY3JpcHQgc3RyaW5nLiBJdCBpcyBhc3N1bWVkXG4gKiB0aGF0IHRoZSB1bmRlcmx5aW5nIHN0cmluZyBoYXMgYmVlbiBlbmNvZGVkIGFzIFVURi04LlxuICpcbiAqIEBwYXJhbSBzdHIgVGhlIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdGcm9tQmFzZTY0VVJMKHN0cikge1xuICAgIGNvbnN0IGNvbnYgPSBbXTtcbiAgICBjb25zdCB1dGY4RW1pdCA9IChjb2RlcG9pbnQpID0+IHtcbiAgICAgICAgY29udi5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVwb2ludCkpO1xuICAgIH07XG4gICAgY29uc3QgdXRmOFN0YXRlID0ge1xuICAgICAgICB1dGY4c2VxOiAwLFxuICAgICAgICBjb2RlcG9pbnQ6IDAsXG4gICAgfTtcbiAgICBjb25zdCBiNjRTdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBjb25zdCBieXRlRW1pdCA9IChieXRlKSA9PiB7XG4gICAgICAgIHN0cmluZ0Zyb21VVEY4KGJ5dGUsIHV0ZjhTdGF0ZSwgdXRmOEVtaXQpO1xuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYnl0ZUZyb21CYXNlNjRVUkwoc3RyLmNoYXJDb2RlQXQoaSksIGI2NFN0YXRlLCBieXRlRW1pdCk7XG4gICAgfVxuICAgIHJldHVybiBjb252LmpvaW4oJycpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgY29kZXBvaW50IHRvIGEgbXVsdGktYnl0ZSBVVEYtOCBzZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0gY29kZXBvaW50IFRoZSBVbmljb2RlIGNvZGVwb2ludC5cbiAqIEBwYXJhbSBlbWl0ICAgICAgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggVVRGLTggYnl0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvZGVwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvZGVwb2ludFRvVVRGOChjb2RlcG9pbnQsIGVtaXQpIHtcbiAgICBpZiAoY29kZXBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgZW1pdChjb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweDdmZikge1xuICAgICAgICBlbWl0KDB4YzAgfCAoY29kZXBvaW50ID4+IDYpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKGNvZGVwb2ludCAmIDB4M2YpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgIGVtaXQoMHhlMCB8IChjb2RlcG9pbnQgPj4gMTIpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gNikgJiAweDNmKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4MTBmZmZmKSB7XG4gICAgICAgIGVtaXQoMHhmMCB8IChjb2RlcG9pbnQgPj4gMTgpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gMTIpICYgMHgzZikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoKGNvZGVwb2ludCA+PiA2KSAmIDB4M2YpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKGNvZGVwb2ludCAmIDB4M2YpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBVbmljb2RlIGNvZGVwb2ludDogJHtjb2RlcG9pbnQudG9TdHJpbmcoMTYpfWApO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgc3RyaW5nIHRvIGEgc2VxdWVuY2Ugb2YgVVRGLTggYnl0ZXMuXG4gKlxuICogQHBhcmFtIHN0ciAgVGhlIHN0cmluZyB0byBjb252ZXJ0IHRvIFVURi04LlxuICogQHBhcmFtIGVtaXQgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggVVRGLTggYnl0ZSBvZiB0aGUgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0ciwgZW1pdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBjb2RlcG9pbnQgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGVwb2ludCA+IDB4ZDdmZiAmJiBjb2RlcG9pbnQgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICAvLyBtb3N0IFVURi0xNiBjb2RlcG9pbnRzIGFyZSBVbmljb2RlIGNvZGVwb2ludHMsIGV4Y2VwdCB2YWx1ZXMgaW4gdGhpc1xuICAgICAgICAgICAgLy8gcmFuZ2Ugd2hlcmUgdGhlIG5leHQgVVRGLTE2IGNvZGVwb2ludCBuZWVkcyB0byBiZSBjb21iaW5lZCB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBvbmUgdG8gZ2V0IHRoZSBVbmljb2RlIGNvZGVwb2ludFxuICAgICAgICAgICAgY29uc3QgaGlnaFN1cnJvZ2F0ZSA9ICgoY29kZXBvaW50IC0gMHhkODAwKSAqIDB4NDAwKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGNvbnN0IGxvd1N1cnJvZ2F0ZSA9IChzdHIuY2hhckNvZGVBdChpICsgMSkgLSAweGRjMDApICYgMHhmZmZmO1xuICAgICAgICAgICAgY29kZXBvaW50ID0gKGxvd1N1cnJvZ2F0ZSB8IGhpZ2hTdXJyb2dhdGUpICsgMHgxMDAwMDtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlcG9pbnRUb1VURjgoY29kZXBvaW50LCBlbWl0KTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgVVRGLTggYnl0ZSB0byBhIFVuaWNvZGUgY29kZXBvaW50LlxuICpcbiAqIEBwYXJhbSBieXRlICBUaGUgVVRGLTggYnl0ZSBuZXh0IGluIHRoZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSBzdGF0ZSBUaGUgc2hhcmVkIHN0YXRlIGJldHdlZW4gY29uc2VjdXRpdmUgVVRGLTggYnl0ZXMgaW4gdGhlXG4gKiAgICAgICAgICAgICAgc2VxdWVuY2UsIGFuIG9iamVjdCB3aXRoIHRoZSBzaGFwZSBgeyB1dGY4c2VxOiAwLCBjb2RlcG9pbnQ6IDAgfWAuXG4gKiBAcGFyYW0gZW1pdCAgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggY29kZXBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbVVURjgoYnl0ZSwgc3RhdGUsIGVtaXQpIHtcbiAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMCkge1xuICAgICAgICBpZiAoYnl0ZSA8PSAweDdmKSB7XG4gICAgICAgICAgICBlbWl0KGJ5dGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgMSBsZWFkaW5nIGJpdHMgdW50aWwgeW91IHJlYWNoIDBcbiAgICAgICAgZm9yIChsZXQgbGVhZGluZ0JpdCA9IDE7IGxlYWRpbmdCaXQgPCA2OyBsZWFkaW5nQml0ICs9IDEpIHtcbiAgICAgICAgICAgIGlmICgoKGJ5dGUgPj4gKDcgLSBsZWFkaW5nQml0KSkgJiAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnV0ZjhzZXEgPSBsZWFkaW5nQml0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAyKSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgMzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMykge1xuICAgICAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDE1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDQpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IHNlcXVlbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUudXRmOHNlcSAtPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS51dGY4c2VxID4gMCkge1xuICAgICAgICBpZiAoYnl0ZSA8PSAweDdmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVRGLTggc2VxdWVuY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSAoc3RhdGUuY29kZXBvaW50IDw8IDYpIHwgKGJ5dGUgJiA2Myk7XG4gICAgICAgIHN0YXRlLnV0ZjhzZXEgLT0gMTtcbiAgICAgICAgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDApIHtcbiAgICAgICAgICAgIGVtaXQoc3RhdGUuY29kZXBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGRpZmZlcmVudCB0eXBlcyBvZiBzdHJpbmdzIHRvIFVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFVybFRvVWludDhBcnJheShzdHIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBjb25zdCBvbkJ5dGUgPSAoYnl0ZSkgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChieXRlKTtcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVGcm9tQmFzZTY0VVJMKHN0ci5jaGFyQ29kZUF0KGkpLCBzdGF0ZSwgb25CeXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9VaW50OEFycmF5KHN0cikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHN0cmluZ1RvVVRGOChzdHIsIChieXRlKSA9PiByZXN1bHQucHVzaChieXRlKSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjR1cmwuanMubWFwIl0sIm5hbWVzIjpbIlRPX0JBU0U2NFVSTCIsInNwbGl0IiwiSUdOT1JFX0JBU0U2NFVSTCIsIkZST01fQkFTRTY0VVJMIiwiY2hhck1hcCIsIkFycmF5IiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJieXRlVG9CYXNlNjRVUkwiLCJieXRlIiwic3RhdGUiLCJlbWl0IiwicXVldWUiLCJxdWV1ZWRCaXRzIiwicG9zIiwiYnl0ZUZyb21CYXNlNjRVUkwiLCJjaGFyQ29kZSIsImJpdHMiLCJFcnJvciIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInN0cmluZ1RvQmFzZTY0VVJMIiwic3RyIiwiYmFzZTY0IiwiZW1pdHRlciIsImNoYXIiLCJwdXNoIiwic3RyaW5nVG9VVEY4Iiwiam9pbiIsInN0cmluZ0Zyb21CYXNlNjRVUkwiLCJjb252IiwidXRmOEVtaXQiLCJjb2RlcG9pbnQiLCJmcm9tQ29kZVBvaW50IiwidXRmOFN0YXRlIiwidXRmOHNlcSIsImI2NFN0YXRlIiwiYnl0ZUVtaXQiLCJzdHJpbmdGcm9tVVRGOCIsImNvZGVwb2ludFRvVVRGOCIsInRvU3RyaW5nIiwiaGlnaFN1cnJvZ2F0ZSIsImxvd1N1cnJvZ2F0ZSIsImxlYWRpbmdCaXQiLCJiYXNlNjRVcmxUb1VpbnQ4QXJyYXkiLCJyZXN1bHQiLCJvbkJ5dGUiLCJVaW50OEFycmF5Iiwic3RyaW5nVG9VaW50OEFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/base64url.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/constants.js":
/*!************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/constants.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_VERSIONS: () => (/* binding */ API_VERSIONS),\n/* harmony export */   API_VERSION_HEADER_NAME: () => (/* binding */ API_VERSION_HEADER_NAME),\n/* harmony export */   AUDIENCE: () => (/* binding */ AUDIENCE),\n/* harmony export */   AUTO_REFRESH_TICK_DURATION_MS: () => (/* binding */ AUTO_REFRESH_TICK_DURATION_MS),\n/* harmony export */   AUTO_REFRESH_TICK_THRESHOLD: () => (/* binding */ AUTO_REFRESH_TICK_THRESHOLD),\n/* harmony export */   BASE64URL_REGEX: () => (/* binding */ BASE64URL_REGEX),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   EXPIRY_MARGIN_MS: () => (/* binding */ EXPIRY_MARGIN_MS),\n/* harmony export */   GOTRUE_URL: () => (/* binding */ GOTRUE_URL),\n/* harmony export */   JWKS_TTL: () => (/* binding */ JWKS_TTL),\n/* harmony export */   NETWORK_FAILURE: () => (/* binding */ NETWORK_FAILURE),\n/* harmony export */   STORAGE_KEY: () => (/* binding */ STORAGE_KEY)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n\n/** Current session will be checked for refresh at this interval. */ const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */ const AUTO_REFRESH_TICK_THRESHOLD = 3;\n/*\n * Earliest time before an access token expires that the session should be refreshed.\n */ const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;\nconst GOTRUE_URL = \"http://localhost:9999\";\nconst STORAGE_KEY = \"supabase.auth.token\";\nconst AUDIENCE = \"\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `gotrue-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`\n};\nconst NETWORK_FAILURE = {\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2\n};\nconst API_VERSION_HEADER_NAME = \"X-Supabase-Api-Version\";\nconst API_VERSIONS = {\n    \"2024-01-01\": {\n        timestamp: Date.parse(\"2024-01-01T00:00:00.0Z\"),\n        name: \"2024-01-01\"\n    }\n};\nconst BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;\nconst JWKS_TTL = 600000; // 10 minutes\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ3BDLGtFQUFrRSxHQUMzRCxNQUFNQyxnQ0FBZ0MsS0FBSyxLQUFLO0FBQ3ZEO3lGQUN5RixHQUNsRixNQUFNQyw4QkFBOEIsRUFBRTtBQUM3Qzs7Q0FFQyxHQUNNLE1BQU1DLG1CQUFtQkQsOEJBQThCRCw4QkFBOEI7QUFDckYsTUFBTUcsYUFBYSx3QkFBd0I7QUFDM0MsTUFBTUMsY0FBYyxzQkFBc0I7QUFDMUMsTUFBTUMsV0FBVyxHQUFHO0FBQ3BCLE1BQU1DLGtCQUFrQjtJQUFFLGlCQUFpQixDQUFDLFVBQVUsRUFBRVAsNkNBQU9BLENBQUMsQ0FBQztBQUFDLEVBQUU7QUFDcEUsTUFBTVEsa0JBQWtCO0lBQzNCQyxhQUFhO0lBQ2JDLGdCQUFnQjtBQUNwQixFQUFFO0FBQ0ssTUFBTUMsMEJBQTBCLHlCQUF5QjtBQUN6RCxNQUFNQyxlQUFlO0lBQ3hCLGNBQWM7UUFDVkMsV0FBV0MsS0FBS0MsS0FBSyxDQUFDO1FBQ3RCQyxNQUFNO0lBQ1Y7QUFDSixFQUFFO0FBQ0ssTUFBTUMsa0JBQWtCLHVEQUF1RDtBQUMvRSxNQUFNQyxXQUFXLE9BQU8sQ0FBQyxhQUFhO0NBQzdDLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2F1dGgtanNAMi42OS4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzP2NjYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG4vKiogQ3VycmVudCBzZXNzaW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgcmVmcmVzaCBhdCB0aGlzIGludGVydmFsLiAqL1xuZXhwb3J0IGNvbnN0IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TID0gMzAgKiAxMDAwO1xuLyoqXG4gKiBBIHRva2VuIHJlZnJlc2ggd2lsbCBiZSBhdHRlbXB0ZWQgdGhpcyBtYW55IHRpY2tzIGJlZm9yZSB0aGUgY3VycmVudCBzZXNzaW9uIGV4cGlyZXMuICovXG5leHBvcnQgY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEID0gMztcbi8qXG4gKiBFYXJsaWVzdCB0aW1lIGJlZm9yZSBhbiBhY2Nlc3MgdG9rZW4gZXhwaXJlcyB0aGF0IHRoZSBzZXNzaW9uIHNob3VsZCBiZSByZWZyZXNoZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBFWFBJUllfTUFSR0lOX01TID0gQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEICogQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVM7XG5leHBvcnQgY29uc3QgR09UUlVFX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0Ojk5OTknO1xuZXhwb3J0IGNvbnN0IFNUT1JBR0VfS0VZID0gJ3N1cGFiYXNlLmF1dGgudG9rZW4nO1xuZXhwb3J0IGNvbnN0IEFVRElFTkNFID0gJyc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBnb3RydWUtanMvJHt2ZXJzaW9ufWAgfTtcbmV4cG9ydCBjb25zdCBORVRXT1JLX0ZBSUxVUkUgPSB7XG4gICAgTUFYX1JFVFJJRVM6IDEwLFxuICAgIFJFVFJZX0lOVEVSVkFMOiAyLCAvLyBpbiBkZWNpc2Vjb25kc1xufTtcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSA9ICdYLVN1cGFiYXNlLUFwaS1WZXJzaW9uJztcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTlMgPSB7XG4gICAgJzIwMjQtMDEtMDEnOiB7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5wYXJzZSgnMjAyNC0wMS0wMVQwMDowMDowMC4wWicpLFxuICAgICAgICBuYW1lOiAnMjAyNC0wMS0wMScsXG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgQkFTRTY0VVJMX1JFR0VYID0gL14oW2EtejAtOV8tXXs0fSkqKCR8W2EtejAtOV8tXXszfSR8W2EtejAtOV8tXXsyfSQpJC9pO1xuZXhwb3J0IGNvbnN0IEpXS1NfVFRMID0gNjAwMDAwOyAvLyAxMCBtaW51dGVzXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUyIsIkFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCIsIkVYUElSWV9NQVJHSU5fTVMiLCJHT1RSVUVfVVJMIiwiU1RPUkFHRV9LRVkiLCJBVURJRU5DRSIsIkRFRkFVTFRfSEVBREVSUyIsIk5FVFdPUktfRkFJTFVSRSIsIk1BWF9SRVRSSUVTIiwiUkVUUllfSU5URVJWQUwiLCJBUElfVkVSU0lPTl9IRUFERVJfTkFNRSIsIkFQSV9WRVJTSU9OUyIsInRpbWVzdGFtcCIsIkRhdGUiLCJwYXJzZSIsIm5hbWUiLCJCQVNFNjRVUkxfUkVHRVgiLCJKV0tTX1RUTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/errors.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/errors.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthApiError: () => (/* binding */ AuthApiError),\n/* harmony export */   AuthError: () => (/* binding */ AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* binding */ AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* binding */ AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* binding */ AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* binding */ AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* binding */ AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* binding */ AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* binding */ AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* binding */ AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* binding */ AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* binding */ CustomAuthError),\n/* harmony export */   isAuthApiError: () => (/* binding */ isAuthApiError),\n/* harmony export */   isAuthError: () => (/* binding */ isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* binding */ isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* binding */ isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* binding */ isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* binding */ isAuthWeakPasswordError)\n/* harmony export */ });\nclass AuthError extends Error {\n    constructor(message, status, code){\n        super(message);\n        this.__isAuthError = true;\n        this.name = \"AuthError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthError(error) {\n    return typeof error === \"object\" && error !== null && \"__isAuthError\" in error;\n}\nclass AuthApiError extends AuthError {\n    constructor(message, status, code){\n        super(message, status, code);\n        this.name = \"AuthApiError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthApiError(error) {\n    return isAuthError(error) && error.name === \"AuthApiError\";\n}\nclass AuthUnknownError extends AuthError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"AuthUnknownError\";\n        this.originalError = originalError;\n    }\n}\nclass CustomAuthError extends AuthError {\n    constructor(message, name, status, code){\n        super(message, status, code);\n        this.name = name;\n        this.status = status;\n    }\n}\nclass AuthSessionMissingError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session missing!\", \"AuthSessionMissingError\", 400, undefined);\n    }\n}\nfunction isAuthSessionMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthSessionMissingError\";\n}\nclass AuthInvalidTokenResponseError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session or user missing\", \"AuthInvalidTokenResponseError\", 500, undefined);\n    }\n}\nclass AuthInvalidCredentialsError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidCredentialsError\", 400, undefined);\n    }\n}\nclass AuthImplicitGrantRedirectError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthImplicitGrantRedirectError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\nfunction isAuthImplicitGrantRedirectError(error) {\n    return isAuthError(error) && error.name === \"AuthImplicitGrantRedirectError\";\n}\nclass AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthPKCEGrantCodeExchangeError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\nclass AuthRetryableFetchError extends CustomAuthError {\n    constructor(message, status){\n        super(message, \"AuthRetryableFetchError\", status, undefined);\n    }\n}\nfunction isAuthRetryableFetchError(error) {\n    return isAuthError(error) && error.name === \"AuthRetryableFetchError\";\n}\n/**\n * This error is thrown on certain methods when the password used is deemed\n * weak. Inspect the reasons to identify what password strength rules are\n * inadequate.\n */ class AuthWeakPasswordError extends CustomAuthError {\n    constructor(message, status, reasons){\n        super(message, \"AuthWeakPasswordError\", status, \"weak_password\");\n        this.reasons = reasons;\n    }\n}\nfunction isAuthWeakPasswordError(error) {\n    return isAuthError(error) && error.name === \"AuthWeakPasswordError\";\n}\nclass AuthInvalidJwtError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidJwtError\", 400, \"invalid_jwt\");\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTyxNQUFNQSxrQkFBa0JDO0lBQzNCQyxZQUFZQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQy9CLEtBQUssQ0FBQ0Y7UUFDTixJQUFJLENBQUNHLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ08sU0FBU0csWUFBWUMsS0FBSztJQUM3QixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLG1CQUFtQkE7QUFDN0U7QUFDTyxNQUFNQyxxQkFBcUJWO0lBQzlCRSxZQUFZQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQy9CLEtBQUssQ0FBQ0YsU0FBU0MsUUFBUUM7UUFDdkIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNILE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLElBQUksR0FBR0E7SUFDaEI7QUFDSjtBQUNPLFNBQVNNLGVBQWVGLEtBQUs7SUFDaEMsT0FBT0QsWUFBWUMsVUFBVUEsTUFBTUYsSUFBSSxLQUFLO0FBQ2hEO0FBQ08sTUFBTUsseUJBQXlCWjtJQUNsQ0UsWUFBWUMsT0FBTyxFQUFFVSxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDVjtRQUNOLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDTSxhQUFhLEdBQUdBO0lBQ3pCO0FBQ0o7QUFDTyxNQUFNQyx3QkFBd0JkO0lBQ2pDRSxZQUFZQyxPQUFPLEVBQUVJLElBQUksRUFBRUgsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDckMsS0FBSyxDQUFDRixTQUFTQyxRQUFRQztRQUN2QixJQUFJLENBQUNFLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNILE1BQU0sR0FBR0E7SUFDbEI7QUFDSjtBQUNPLE1BQU1XLGdDQUFnQ0Q7SUFDekNaLGFBQWM7UUFDVixLQUFLLENBQUMseUJBQXlCLDJCQUEyQixLQUFLYztJQUNuRTtBQUNKO0FBQ08sU0FBU0MsMEJBQTBCUixLQUFLO0lBQzNDLE9BQU9ELFlBQVlDLFVBQVVBLE1BQU1GLElBQUksS0FBSztBQUNoRDtBQUNPLE1BQU1XLHNDQUFzQ0o7SUFDL0NaLGFBQWM7UUFDVixLQUFLLENBQUMsZ0NBQWdDLGlDQUFpQyxLQUFLYztJQUNoRjtBQUNKO0FBQ08sTUFBTUcsb0NBQW9DTDtJQUM3Q1osWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0EsU0FBUywrQkFBK0IsS0FBS2E7SUFDdkQ7QUFDSjtBQUNPLE1BQU1JLHVDQUF1Q047SUFDaERaLFlBQVlDLE9BQU8sRUFBRWtCLFVBQVUsSUFBSSxDQUFFO1FBQ2pDLEtBQUssQ0FBQ2xCLFNBQVMsa0NBQWtDLEtBQUthO1FBQ3RELElBQUksQ0FBQ0ssT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FDLFNBQVM7UUFDTCxPQUFPO1lBQ0hmLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZKLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQmlCLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1FBQ3pCO0lBQ0o7QUFDSjtBQUNPLFNBQVNFLGlDQUFpQ2QsS0FBSztJQUNsRCxPQUFPRCxZQUFZQyxVQUFVQSxNQUFNRixJQUFJLEtBQUs7QUFDaEQ7QUFDTyxNQUFNaUIsdUNBQXVDVjtJQUNoRFosWUFBWUMsT0FBTyxFQUFFa0IsVUFBVSxJQUFJLENBQUU7UUFDakMsS0FBSyxDQUFDbEIsU0FBUyxrQ0FBa0MsS0FBS2E7UUFDdEQsSUFBSSxDQUFDSyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDbkI7SUFDQUMsU0FBUztRQUNMLE9BQU87WUFDSGYsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkosU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJDLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CaUIsU0FBUyxJQUFJLENBQUNBLE9BQU87UUFDekI7SUFDSjtBQUNKO0FBQ08sTUFBTUksZ0NBQWdDWDtJQUN6Q1osWUFBWUMsT0FBTyxFQUFFQyxNQUFNLENBQUU7UUFDekIsS0FBSyxDQUFDRCxTQUFTLDJCQUEyQkMsUUFBUVk7SUFDdEQ7QUFDSjtBQUNPLFNBQVNVLDBCQUEwQmpCLEtBQUs7SUFDM0MsT0FBT0QsWUFBWUMsVUFBVUEsTUFBTUYsSUFBSSxLQUFLO0FBQ2hEO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU1vQiw4QkFBOEJiO0lBQ3ZDWixZQUFZQyxPQUFPLEVBQUVDLE1BQU0sRUFBRXdCLE9BQU8sQ0FBRTtRQUNsQyxLQUFLLENBQUN6QixTQUFTLHlCQUF5QkMsUUFBUTtRQUNoRCxJQUFJLENBQUN3QixPQUFPLEdBQUdBO0lBQ25CO0FBQ0o7QUFDTyxTQUFTQyx3QkFBd0JwQixLQUFLO0lBQ3pDLE9BQU9ELFlBQVlDLFVBQVVBLE1BQU1GLElBQUksS0FBSztBQUNoRDtBQUNPLE1BQU11Qiw0QkFBNEJoQjtJQUNyQ1osWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0EsU0FBUyx1QkFBdUIsS0FBSztJQUMvQztBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrYXV0aC1qc0AyLjY5LjEvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9lcnJvcnMuanM/Y2QyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fX2lzQXV0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0F1dGhFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhFcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdfX2lzQXV0aEVycm9yJyBpbiBlcnJvcjtcbn1cbmV4cG9ydCBjbGFzcyBBdXRoQXBpRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aEFwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEFwaUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aEFwaUVycm9yJztcbn1cbmV4cG9ydCBjbGFzcyBBdXRoVW5rbm93bkVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aFVua25vd25FcnJvcic7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEN1c3RvbUF1dGhFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbmFtZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBdXRoIHNlc3Npb24gbWlzc2luZyEnLCAnQXV0aFNlc3Npb25NaXNzaW5nRXJyb3InLCA0MDAsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcic7XG59XG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQXV0aCBzZXNzaW9uIG9yIHVzZXIgbWlzc2luZycsICdBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3InLCA0MDAsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3InO1xufVxuZXhwb3J0IGNsYXNzIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InLCBzdGF0dXMsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcic7XG59XG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIG9uIGNlcnRhaW4gbWV0aG9kcyB3aGVuIHRoZSBwYXNzd29yZCB1c2VkIGlzIGRlZW1lZFxuICogd2Vhay4gSW5zcGVjdCB0aGUgcmVhc29ucyB0byBpZGVudGlmeSB3aGF0IHBhc3N3b3JkIHN0cmVuZ3RoIHJ1bGVzIGFyZVxuICogaW5hZGVxdWF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhXZWFrUGFzc3dvcmRFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCByZWFzb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InLCBzdGF0dXMsICd3ZWFrX3Bhc3N3b3JkJyk7XG4gICAgICAgIHRoaXMucmVhc29ucyA9IHJlYXNvbnM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFdlYWtQYXNzd29yZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFdlYWtQYXNzd29yZEVycm9yJztcbn1cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZEp3dEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW52YWxpZEp3dEVycm9yJywgNDAwLCAnaW52YWxpZF9qd3QnKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbIkF1dGhFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwic3RhdHVzIiwiY29kZSIsIl9faXNBdXRoRXJyb3IiLCJuYW1lIiwiaXNBdXRoRXJyb3IiLCJlcnJvciIsIkF1dGhBcGlFcnJvciIsImlzQXV0aEFwaUVycm9yIiwiQXV0aFVua25vd25FcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJDdXN0b21BdXRoRXJyb3IiLCJBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsInVuZGVmaW5lZCIsImlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IiLCJBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciIsIkF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciIsIkF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsImRldGFpbHMiLCJ0b0pTT04iLCJpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsIkF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciIsIkF1dGhSZXRyeWFibGVGZXRjaEVycm9yIiwiaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciIsIkF1dGhXZWFrUGFzc3dvcmRFcnJvciIsInJlYXNvbnMiLCJpc0F1dGhXZWFrUGFzc3dvcmRFcnJvciIsIkF1dGhJbnZhbGlkSnd0RXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/fetch.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/fetch.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _generateLinkResponse: () => (/* binding */ _generateLinkResponse),\n/* harmony export */   _noResolveJsonResponse: () => (/* binding */ _noResolveJsonResponse),\n/* harmony export */   _request: () => (/* binding */ _request),\n/* harmony export */   _sessionResponse: () => (/* binding */ _sessionResponse),\n/* harmony export */   _sessionResponsePassword: () => (/* binding */ _sessionResponsePassword),\n/* harmony export */   _ssoResponse: () => (/* binding */ _ssoResponse),\n/* harmony export */   _userResponse: () => (/* binding */ _userResponse),\n/* harmony export */   handleError: () => (/* binding */ handleError)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\nvar __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\nconst _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [\n    502,\n    503,\n    504\n];\nasync function handleError(error) {\n    var _a;\n    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_1__.looksLikeFetchResponse)(error)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    } catch (e) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(_getErrorMessage(e), e);\n    }\n    let errorCode = undefined;\n    const responseAPIVersion = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.parseResponseAPIVersion)(error);\n    if (responseAPIVersion && responseAPIVersion.getTime() >= _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].timestamp && typeof data === \"object\" && data && typeof data.code === \"string\") {\n        errorCode = data.code;\n    } else if (typeof data === \"object\" && data && typeof data.error_code === \"string\") {\n        errorCode = data.error_code;\n    }\n    if (!errorCode) {\n        // Legacy support for weak password errors, when there were no error codes\n        if (typeof data === \"object\" && data && typeof data.weak_password === \"object\" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\n        }\n    } else if (errorCode === \"weak_password\") {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\n    } else if (errorCode === \"session_not_found\") {\n        // The `session_id` inside the JWT does not correspond to a row in the\n        // `sessions` table. This usually means the user has signed out, has been\n        // deleted, or their session has somehow been terminated.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n    }\n    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\n}\nconst _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\") {\n        return params;\n    }\n    params.headers = Object.assign({\n        \"Content-Type\": \"application/json;charset=UTF-8\"\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nasync function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (!headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME]) {\n        headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME] = _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].name;\n    }\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers[\"Authorization\"] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs[\"redirect_to\"] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? \"?\" + new URLSearchParams(qs).toString() : \"\";\n    const data = await _handleRequest(fetcher, method, url + queryString, {\n        headers,\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {\n        data: Object.assign({}, data),\n        error: null\n    };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, Object.assign({}, requestParams));\n    } catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    } catch (e) {\n        await handleError(e);\n    }\n}\nfunction _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.expiresAt)(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            session,\n            user\n        },\n        error: null\n    };\n}\nfunction _sessionResponsePassword(data) {\n    const response = _sessionResponse(data);\n    if (!response.error && data.weak_password && typeof data.weak_password === \"object\" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === \"string\" && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n        response.data.weak_password = data.weak_password;\n    }\n    return response;\n}\nfunction _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            user\n        },\n        error: null\n    };\n}\nfunction _ssoResponse(data) {\n    return {\n        data,\n        error: null\n    };\n}\nfunction _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, [\n        \"action_link\",\n        \"email_otp\",\n        \"hashed_token\",\n        \"redirect_to\",\n        \"verification_type\"\n    ]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user\n        },\n        error: null\n    };\n}\nfunction _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */ function hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsU0FBUyxTQUFLLElBQUksU0FBSSxDQUFDQSxNQUFNLElBQUssU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hELElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJSSxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUCxHQUFHRyxNQUFNRixFQUFFTyxPQUFPLENBQUNMLEtBQUssR0FDOUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDZixJQUFJSCxLQUFLLFFBQVEsT0FBT0ksT0FBT0sscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLElBQUlDLE9BQU9LLHFCQUFxQixDQUFDVCxJQUFJVSxJQUFJUCxFQUFFUSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSVQsRUFBRU8sT0FBTyxDQUFDTCxDQUFDLENBQUNPLEVBQUUsSUFBSSxLQUFLTixPQUFPQyxTQUFTLENBQUNPLG9CQUFvQixDQUFDTCxJQUFJLENBQUNQLEdBQUdHLENBQUMsQ0FBQ08sRUFBRSxHQUN6RVIsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ3pCO0lBQ0osT0FBT1I7QUFDWDtBQUNvRTtBQUNtQjtBQUM2QztBQUNwSSxNQUFNcUIsbUJBQW1CLENBQUNDLE1BQVFBLElBQUlDLEdBQUcsSUFBSUQsSUFBSUUsT0FBTyxJQUFJRixJQUFJRyxpQkFBaUIsSUFBSUgsSUFBSUksS0FBSyxJQUFJQyxLQUFLQyxTQUFTLENBQUNOO0FBQ2pILE1B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RCxJQUFJO0lBQzdCLE9BQU87UUFBRUE7UUFBTVIsT0FBTztJQUFLO0FBQy9CO0FBQ08sU0FBUzRELHNCQUFzQnBELElBQUk7SUFDdEMsTUFBTSxFQUFFcUQsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxpQkFBaUIsRUFBRSxHQUFHekQsTUFBTTBELE9BQU8vRixPQUFPcUMsTUFBTTtRQUFDO1FBQWU7UUFBYTtRQUFnQjtRQUFlO0tBQW9CO0lBQzNMLE1BQU0yRCxhQUFhO1FBQ2ZOO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0o7SUFDQSxNQUFNVixPQUFPL0UsT0FBT3NELE1BQU0sQ0FBQyxDQUFDLEdBQUdvQztJQUMvQixPQUFPO1FBQ0gxRCxNQUFNO1lBQ0YyRDtZQUNBWjtRQUNKO1FBQ0F2RCxPQUFPO0lBQ1g7QUFDSjtBQUNPLFNBQVNvRSx1QkFBdUI1RCxJQUFJO0lBQ3ZDLE9BQU9BO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsU0FBUzRDLFdBQVc1QyxJQUFJO0lBQ3BCLE9BQU9BLEtBQUs2RCxZQUFZLElBQUk3RCxLQUFLOEQsYUFBYSxJQUFJOUQsS0FBSzhDLFVBQVU7QUFDckUsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzP2NjYzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IHsgQVBJX1ZFUlNJT05TLCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGV4cGlyZXNBdCwgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSwgcGFyc2VSZXNwb25zZUFQSVZlcnNpb24gfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgQXV0aEFwaUVycm9yLCBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciwgQXV0aFdlYWtQYXNzd29yZEVycm9yLCBBdXRoVW5rbm93bkVycm9yLCBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciwgfSBmcm9tICcuL2Vycm9ycyc7XG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG5jb25zdCBORVRXT1JLX0VSUk9SX0NPREVTID0gWzUwMiwgNTAzLCA1MDRdO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghbG9va3NMaWtlRmV0Y2hSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKTtcbiAgICB9XG4gICAgaWYgKE5FVFdPUktfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAvLyBzdGF0dXMgaW4gNTAwLi4uNTk5IHJhbmdlIC0gc2VydmVyIGhhZCBhbiBlcnJvciwgcmVxdWVzdCBtaWdodCBiZSByZXRyeWVkLlxuICAgICAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yLnN0YXR1cyk7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBlcnJvci5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIGUpO1xuICAgIH1cbiAgICBsZXQgZXJyb3JDb2RlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc3BvbnNlQVBJVmVyc2lvbiA9IHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKGVycm9yKTtcbiAgICBpZiAocmVzcG9uc2VBUElWZXJzaW9uICYmXG4gICAgICAgIHJlc3BvbnNlQVBJVmVyc2lvbi5nZXRUaW1lKCkgPj0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10udGltZXN0YW1wICYmXG4gICAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBkYXRhICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yQ29kZSA9IGRhdGEuY29kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgdHlwZW9mIGRhdGEuZXJyb3JfY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JDb2RlID0gZGF0YS5lcnJvcl9jb2RlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yQ29kZSkge1xuICAgICAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3Igd2VhayBwYXNzd29yZCBlcnJvcnMsIHdoZW4gdGhlcmUgd2VyZSBubyBlcnJvciBjb2Rlc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBkYXRhICYmXG4gICAgICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGEsIGkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMsIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvckNvZGUgPT09ICd3ZWFrX3Bhc3N3b3JkJykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cywgKChfYSA9IGRhdGEud2Vha19wYXNzd29yZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYXNvbnMpIHx8IFtdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnc2Vzc2lvbl9ub3RfZm91bmQnKSB7XG4gICAgICAgIC8vIFRoZSBgc2Vzc2lvbl9pZGAgaW5zaWRlIHRoZSBKV1QgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIHJvdyBpbiB0aGVcbiAgICAgICAgLy8gYHNlc3Npb25zYCB0YWJsZS4gVGhpcyB1c3VhbGx5IG1lYW5zIHRoZSB1c2VyIGhhcyBzaWduZWQgb3V0LCBoYXMgYmVlblxuICAgICAgICAvLyBkZWxldGVkLCBvciB0aGVpciBzZXNzaW9uIGhhcyBzb21laG93IGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBBdXRoQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCwgZXJyb3JDb2RlKTtcbn1cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgbWV0aG9kLCBoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9IH07XG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyYW1zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmICghaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0pIHtcbiAgICAgICAgaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0gPSBBUElfVkVSU0lPTlNbJzIwMjQtMDEtMDEnXS5uYW1lO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmp3dCkge1xuICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7b3B0aW9ucy5qd3R9YDtcbiAgICB9XG4gICAgY29uc3QgcXMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbykge1xuICAgICAgICBxc1sncmVkaXJlY3RfdG8nXSA9IG9wdGlvbnMucmVkaXJlY3RUbztcbiAgICB9XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBPYmplY3Qua2V5cyhxcykubGVuZ3RoID8gJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhxcykudG9TdHJpbmcoKSA6ICcnO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCArIHF1ZXJ5U3RyaW5nLCB7XG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uLFxuICAgIH0sIHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueGZvcm0pID8gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnhmb3JtKGRhdGEpIDogeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3I6IG51bGwgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaGVyKHVybCwgT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdFBhcmFtcykpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAvLyBmZXRjaCBmYWlsZWQsIGxpa2VseSBkdWUgdG8gYSBuZXR3b3JrIG9yIENPUlMgZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIDApO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHNlc3Npb24gPSBudWxsO1xuICAgIGlmIChoYXNTZXNzaW9uKGRhdGEpKSB7XG4gICAgICAgIHNlc3Npb24gPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgaWYgKCFkYXRhLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgIHNlc3Npb24uZXhwaXJlc19hdCA9IGV4cGlyZXNBdChkYXRhLmV4cGlyZXNfaW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCB1c2VyIH0sIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkKGRhdGEpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IF9zZXNzaW9uUmVzcG9uc2UoZGF0YSk7XG4gICAgaWYgKCFyZXNwb25zZS5lcnJvciAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhLCBpKSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSkpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS53ZWFrX3Bhc3N3b3JkID0gZGF0YS53ZWFrX3Bhc3N3b3JkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gX3VzZXJSZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nzb1Jlc3BvbnNlKGRhdGEpIHtcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9nZW5lcmF0ZUxpbmtSZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgeyBhY3Rpb25fbGluaywgZW1haWxfb3RwLCBoYXNoZWRfdG9rZW4sIHJlZGlyZWN0X3RvLCB2ZXJpZmljYXRpb25fdHlwZSB9ID0gZGF0YSwgcmVzdCA9IF9fcmVzdChkYXRhLCBbXCJhY3Rpb25fbGlua1wiLCBcImVtYWlsX290cFwiLCBcImhhc2hlZF90b2tlblwiLCBcInJlZGlyZWN0X3RvXCIsIFwidmVyaWZpY2F0aW9uX3R5cGVcIl0pO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGFjdGlvbl9saW5rLFxuICAgICAgICBlbWFpbF9vdHAsXG4gICAgICAgIGhhc2hlZF90b2tlbixcbiAgICAgICAgcmVkaXJlY3RfdG8sXG4gICAgICAgIHZlcmlmaWNhdGlvbl90eXBlLFxuICAgIH07XG4gICAgY29uc3QgdXNlciA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3QpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBoYXNTZXNzaW9uIGNoZWNrcyBpZiB0aGUgcmVzcG9uc2Ugb2JqZWN0IGNvbnRhaW5zIGEgdmFsaWQgc2Vzc2lvblxuICogQHBhcmFtIGRhdGEgQSByZXNwb25zZSBvYmplY3RcbiAqIEByZXR1cm5zIHRydWUgaWYgYSBzZXNzaW9uIGlzIGluIHRoZSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBoYXNTZXNzaW9uKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5hY2Nlc3NfdG9rZW4gJiYgZGF0YS5yZWZyZXNoX3Rva2VuICYmIGRhdGEuZXhwaXJlc19pbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6WyJfX3Jlc3QiLCJzIiwiZSIsInQiLCJwIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsImkiLCJsZW5ndGgiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkFQSV9WRVJTSU9OUyIsIkFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIiwiZXhwaXJlc0F0IiwibG9va3NMaWtlRmV0Y2hSZXNwb25zZSIsInBhcnNlUmVzcG9uc2VBUElWZXJzaW9uIiwiQXV0aEFwaUVycm9yIiwiQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IiLCJBdXRoV2Vha1Bhc3N3b3JkRXJyb3IiLCJBdXRoVW5rbm93bkVycm9yIiwiQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IiLCJfZ2V0RXJyb3JNZXNzYWdlIiwiZXJyIiwibXNnIiwibWVzc2FnZSIsImVycm9yX2Rlc2NyaXB0aW9uIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiTkVUV09SS19FUlJPUl9DT0RFUyIsImhhbmRsZUVycm9yIiwiX2EiLCJpbmNsdWRlcyIsInN0YXR1cyIsImRhdGEiLCJqc29uIiwiZXJyb3JDb2RlIiwidW5kZWZpbmVkIiwicmVzcG9uc2VBUElWZXJzaW9uIiwiZ2V0VGltZSIsInRpbWVzdGFtcCIsImNvZGUiLCJlcnJvcl9jb2RlIiwid2Vha19wYXNzd29yZCIsIkFycmF5IiwiaXNBcnJheSIsInJlYXNvbnMiLCJyZWR1Y2UiLCJhIiwiX2dldFJlcXVlc3RQYXJhbXMiLCJtZXRob2QiLCJvcHRpb25zIiwicGFyYW1ldGVycyIsImJvZHkiLCJwYXJhbXMiLCJoZWFkZXJzIiwiYXNzaWduIiwiX3JlcXVlc3QiLCJmZXRjaGVyIiwidXJsIiwibmFtZSIsImp3dCIsInFzIiwicXVlcnkiLCJyZWRpcmVjdFRvIiwicXVlcnlTdHJpbmciLCJrZXlzIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJfaGFuZGxlUmVxdWVzdCIsIm5vUmVzb2x2ZUpzb24iLCJ4Zm9ybSIsInJlcXVlc3RQYXJhbXMiLCJyZXN1bHQiLCJjb25zb2xlIiwib2siLCJfc2Vzc2lvblJlc3BvbnNlIiwic2Vzc2lvbiIsImhhc1Nlc3Npb24iLCJleHBpcmVzX2F0IiwiZXhwaXJlc19pbiIsInVzZXIiLCJfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQiLCJyZXNwb25zZSIsIl91c2VyUmVzcG9uc2UiLCJfc3NvUmVzcG9uc2UiLCJfZ2VuZXJhdGVMaW5rUmVzcG9uc2UiLCJhY3Rpb25fbGluayIsImVtYWlsX290cCIsImhhc2hlZF90b2tlbiIsInJlZGlyZWN0X3RvIiwidmVyaWZpY2F0aW9uX3R5cGUiLCJyZXN0IiwicHJvcGVydGllcyIsIl9ub1Jlc29sdmVKc29uUmVzcG9uc2UiLCJhY2Nlc3NfdG9rZW4iLCJyZWZyZXNoX3Rva2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/fetch.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/helpers.js":
/*!**********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/helpers.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   decodeJWT: () => (/* binding */ decodeJWT),\n/* harmony export */   expiresAt: () => (/* binding */ expiresAt),\n/* harmony export */   generatePKCEChallenge: () => (/* binding */ generatePKCEChallenge),\n/* harmony export */   generatePKCEVerifier: () => (/* binding */ generatePKCEVerifier),\n/* harmony export */   getAlgorithm: () => (/* binding */ getAlgorithm),\n/* harmony export */   getCodeChallengeAndMethod: () => (/* binding */ getCodeChallengeAndMethod),\n/* harmony export */   getItemAsync: () => (/* binding */ getItemAsync),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   looksLikeFetchResponse: () => (/* binding */ looksLikeFetchResponse),\n/* harmony export */   parseParametersFromURL: () => (/* binding */ parseParametersFromURL),\n/* harmony export */   parseResponseAPIVersion: () => (/* binding */ parseResponseAPIVersion),\n/* harmony export */   removeItemAsync: () => (/* binding */ removeItemAsync),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   retryable: () => (/* binding */ retryable),\n/* harmony export */   setItemAsync: () => (/* binding */ setItemAsync),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   supportsLocalStorage: () => (/* binding */ supportsLocalStorage),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   validateExp: () => (/* binding */ validateExp)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n\n\n\nfunction expiresAt(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\nfunction uuid() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nconst isBrowser = ()=> false && 0;\nconst localStorageWriteTests = {\n    tested: false,\n    writable: false\n};\n/**\n * Checks whether localStorage is supported on this browser.\n */ const supportsLocalStorage = ()=>{\n    if (!isBrowser()) {\n        return false;\n    }\n    try {\n        if (typeof globalThis.localStorage !== \"object\") {\n            return false;\n        }\n    } catch (e) {\n        // DOM exception when accessing `localStorage`\n        return false;\n    }\n    if (localStorageWriteTests.tested) {\n        return localStorageWriteTests.writable;\n    }\n    const randomKey = `lswt-${Math.random()}${Math.random()}`;\n    try {\n        globalThis.localStorage.setItem(randomKey, randomKey);\n        globalThis.localStorage.removeItem(randomKey);\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = true;\n    } catch (e) {\n        // localStorage can't be written to\n        // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = false;\n    }\n    return localStorageWriteTests.writable;\n};\n/**\n * Extracts parameters encoded in the URL both in the query and fragment.\n */ function parseParametersFromURL(href) {\n    const result = {};\n    const url = new URL(href);\n    if (url.hash && url.hash[0] === \"#\") {\n        try {\n            const hashSearchParams = new URLSearchParams(url.hash.substring(1));\n            hashSearchParams.forEach((value, key)=>{\n                result[key] = value;\n            });\n        } catch (e) {\n        // hash is not a query string\n        }\n    }\n    // search parameters take precedence over hash parameters\n    url.searchParams.forEach((value, key)=>{\n        result[key] = value;\n    });\n    return result;\n}\nconst resolveFetch = (customFetch)=>{\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    } else if (typeof fetch === \"undefined\") {\n        _fetch = (...args)=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(rsc)/../../../node_modules/.pnpm/@supabase+node-fetch@2.6.15/node_modules/@supabase/node-fetch/lib/index.js\", 23)).then(({ default: fetch1 })=>fetch1(...args));\n    } else {\n        _fetch = fetch;\n    }\n    return (...args)=>_fetch(...args);\n};\nconst looksLikeFetchResponse = (maybeResponse)=>{\n    return typeof maybeResponse === \"object\" && maybeResponse !== null && \"status\" in maybeResponse && \"ok\" in maybeResponse && \"json\" in maybeResponse && typeof maybeResponse.json === \"function\";\n};\n// Storage helpers\nconst setItemAsync = async (storage, key, data)=>{\n    await storage.setItem(key, JSON.stringify(data));\n};\nconst getItemAsync = async (storage, key)=>{\n    const value = await storage.getItem(key);\n    if (!value) {\n        return null;\n    }\n    try {\n        return JSON.parse(value);\n    } catch (_a) {\n        return value;\n    }\n};\nconst removeItemAsync = async (storage, key)=>{\n    await storage.removeItem(key);\n};\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */ class Deferred {\n    constructor(){\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        this.promise = new Deferred.promiseConstructor((res, rej)=>{\n            // eslint-disable-next-line @typescript-eslint/no-extra-semi\n            ;\n            this.resolve = res;\n            this.reject = rej;\n        });\n    }\n}\nDeferred.promiseConstructor = Promise;\nfunction decodeJWT(token) {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError(\"Invalid JWT structure\");\n    }\n    // Regex checks for base64url format\n    for(let i = 0; i < parts.length; i++){\n        if (!_constants__WEBPACK_IMPORTED_MODULE_0__.BASE64URL_REGEX.test(parts[i])) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError(\"JWT not in base64url format\");\n        }\n    }\n    const data = {\n        // using base64url lib\n        header: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[0])),\n        payload: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[1])),\n        signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_2__.base64UrlToUint8Array)(parts[2]),\n        raw: {\n            header: parts[0],\n            payload: parts[1]\n        }\n    };\n    return data;\n}\n/**\n * Creates a promise that resolves to null after some time.\n */ async function sleep(time) {\n    return await new Promise((accept)=>{\n        setTimeout(()=>accept(null), time);\n    });\n}\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */ function retryable(fn, isRetryable) {\n    const promise = new Promise((accept, reject)=>{\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        (async ()=>{\n            for(let attempt = 0; attempt < Infinity; attempt++){\n                try {\n                    const result = await fn(attempt);\n                    if (!isRetryable(attempt, null, result)) {\n                        accept(result);\n                        return;\n                    }\n                } catch (e) {\n                    if (!isRetryable(attempt, e)) {\n                        reject(e);\n                        return;\n                    }\n                }\n            }\n        })();\n    });\n    return promise;\n}\nfunction dec2hex(dec) {\n    return (\"0\" + dec.toString(16)).substr(-2);\n}\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nfunction generatePKCEVerifier() {\n    const verifierLength = 56;\n    const array = new Uint32Array(verifierLength);\n    if (typeof crypto === \"undefined\") {\n        const charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\";\n        const charSetLen = charSet.length;\n        let verifier = \"\";\n        for(let i = 0; i < verifierLength; i++){\n            verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));\n        }\n        return verifier;\n    }\n    crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join(\"\");\n}\nasync function sha256(randomString) {\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(randomString);\n    const hash = await crypto.subtle.digest(\"SHA-256\", encodedData);\n    const bytes = new Uint8Array(hash);\n    return Array.from(bytes).map((c)=>String.fromCharCode(c)).join(\"\");\n}\nasync function generatePKCEChallenge(verifier) {\n    const hasCryptoSupport = typeof crypto !== \"undefined\" && typeof crypto.subtle !== \"undefined\" && typeof TextEncoder !== \"undefined\";\n    if (!hasCryptoSupport) {\n        console.warn(\"WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.\");\n        return verifier;\n    }\n    const hashed = await sha256(verifier);\n    return btoa(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nasync function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {\n    const codeVerifier = generatePKCEVerifier();\n    let storedCodeVerifier = codeVerifier;\n    if (isPasswordRecovery) {\n        storedCodeVerifier += \"/PASSWORD_RECOVERY\";\n    }\n    await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);\n    const codeChallenge = await generatePKCEChallenge(codeVerifier);\n    const codeChallengeMethod = codeVerifier === codeChallenge ? \"plain\" : \"s256\";\n    return [\n        codeChallenge,\n        codeChallengeMethod\n    ];\n}\n/** Parses the API version which is 2YYY-MM-DD. */ const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;\nfunction parseResponseAPIVersion(response) {\n    const apiVersion = response.headers.get(_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME);\n    if (!apiVersion) {\n        return null;\n    }\n    if (!apiVersion.match(API_VERSION_REGEX)) {\n        return null;\n    }\n    try {\n        const date = new Date(`${apiVersion}T00:00:00.0Z`);\n        return date;\n    } catch (e) {\n        return null;\n    }\n}\nfunction validateExp(exp) {\n    if (!exp) {\n        throw new Error(\"Missing exp claim\");\n    }\n    const timeNow = Math.floor(Date.now() / 1000);\n    if (exp <= timeNow) {\n        throw new Error(\"JWT has expired\");\n    }\n}\nfunction getAlgorithm(alg) {\n    switch(alg){\n        case \"RS256\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        case \"ES256\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        default:\n            throw new Error(\"Invalid alg claim\");\n    }\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDeEI7QUFDMEI7QUFDbEUsU0FBU0ssVUFBVUMsU0FBUztJQUMvQixNQUFNQyxVQUFVQyxLQUFLQyxLQUFLLENBQUNDLEtBQUtDLEdBQUcsS0FBSztJQUN4QyxPQUFPSixVQUFVRDtBQUNyQjtBQUNPLFNBQVNNO0lBQ1osT0FBTyx1Q0FBdUNDLE9BQU8sQ0FBQyxTQUFTLFNBQVVDLENBQUM7UUFDdEUsTUFBTUMsSUFBSSxLQUFNQyxNQUFNLEtBQUssS0FBTSxHQUFHQyxJQUFJSCxLQUFLLE1BQU1DLElBQUksSUFBSyxNQUFPO1FBQ25FLE9BQU9FLEVBQUVDLFFBQVEsQ0FBQztJQUN0QjtBQUNKO0FBQ08sTUFBTUMsWUFBWSxJQUFNLE1BQWtCLElBQWUsQ0FBb0IsQ0FBWTtBQUNoRyxNQUFNRSx5QkFBeUI7SUFDM0JDLFFBQVE7SUFDUkMsVUFBVTtBQUNkO0FBQ0E7O0NBRUMsR0FDTSxNQUFNQyx1QkFBdUI7SUFDaEMsSUFBSSxDQUFDTCxhQUFhO1FBQ2QsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLElBQUksT0FBT00sV0FBV0MsWUFBWSxLQUFLLFVBQVU7WUFDN0MsT0FBTztRQUNYO0lBQ0osRUFDQSxPQUFPQyxHQUFHO1FBQ04sOENBQThDO1FBQzlDLE9BQU87SUFDWDtJQUNBLElBQUlOLHVCQUF1QkMsTUFBTSxFQUFFO1FBQy9CLE9BQU9ELHVCQUF1QkUsUUFBUTtJQUMxQztJQUNBLE1BQU1LLFlBQVksQ0FBQyxLQUFLLEVBQUVwQixLQUFLUSxNQUFNLEdBQUcsRUFBRVIsS0FBS1EsTUFBTSxHQUFHLENBQUM7SUFDekQsSUFBSTtRQUNBUyxXQUFXQyxZQUFZLENBQUNH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QSxNQUFNM0ksVUFBVUMsS0FBS2lHLEtBQUssQ0FBQy9GLEtBQUtDLEdBQUcsS0FBSztJQUN4QyxJQUFJc0ksT0FBTzFJLFNBQVM7UUFDaEIsTUFBTSxJQUFJMkksTUFBTTtJQUNwQjtBQUNKO0FBQ08sU0FBU0MsYUFBYUMsR0FBRztJQUM1QixPQUFRQTtRQUNKLEtBQUs7WUFDRCxPQUFPO2dCQUNIQyxNQUFNO2dCQUNOakgsTUFBTTtvQkFBRWlILE1BQU07Z0JBQVU7WUFDNUI7UUFDSixLQUFLO1lBQ0QsT0FBTztnQkFDSEEsTUFBTTtnQkFDTkMsWUFBWTtnQkFDWmxILE1BQU07b0JBQUVpSCxNQUFNO2dCQUFVO1lBQzVCO1FBQ0o7WUFDSSxNQUFNLElBQUlILE1BQU07SUFDeEI7QUFDSixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2F1dGgtanNAMi42OS4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcz9kNjRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FLCBCQVNFNjRVUkxfUkVHRVggfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBdXRoSW52YWxpZEp3dEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgYmFzZTY0VXJsVG9VaW50OEFycmF5LCBzdHJpbmdGcm9tQmFzZTY0VVJMIH0gZnJvbSAnLi9iYXNlNjR1cmwnO1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGlyZXNBdChleHBpcmVzSW4pIHtcbiAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgcmV0dXJuIHRpbWVOb3cgKyBleHBpcmVzSW47XG59XG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMgPSB7XG4gICAgdGVzdGVkOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBsb2NhbFN0b3JhZ2UgaXMgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzTG9jYWxTdG9yYWdlID0gKCkgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIERPTSBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmcgYGxvY2FsU3RvcmFnZWBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGU7XG4gICAgfVxuICAgIGNvbnN0IHJhbmRvbUtleSA9IGBsc3d0LSR7TWF0aC5yYW5kb20oKX0ke01hdGgucmFuZG9tKCl9YDtcbiAgICB0cnkge1xuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHJhbmRvbUtleSwgcmFuZG9tS2V5KTtcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShyYW5kb21LZXkpO1xuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBsb2NhbFN0b3JhZ2UgY2FuJ3QgYmUgd3JpdHRlbiB0b1xuICAgICAgICAvLyBodHRwczovL3d3dy5jaHJvbWl1bS5vcmcvZm9yLXRlc3RlcnMvYnVnLXJlcG9ydGluZy1ndWlkZWxpbmVzL3VuY2F1Z2h0LXNlY3VyaXR5ZXJyb3ItZmFpbGVkLXRvLXJlYWQtdGhlLWxvY2Fsc3RvcmFnZS1wcm9wZXJ0eS1mcm9tLXdpbmRvdy1hY2Nlc3MtaXMtZGVuaWVkLWZvci10aGlzLWRvY3VtZW50XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZTtcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZTtcbn07XG4vKipcbiAqIEV4dHJhY3RzIHBhcmFtZXRlcnMgZW5jb2RlZCBpbiB0aGUgVVJMIGJvdGggaW4gdGhlIHF1ZXJ5IGFuZCBmcmFnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwoaHJlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZik7XG4gICAgaWYgKHVybC5oYXNoICYmIHVybC5oYXNoWzBdID09PSAnIycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hTZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5oYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICBoYXNoU2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGhhc2ggaXMgbm90IGEgcXVlcnkgc3RyaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2VhcmNoIHBhcmFtZXRlcnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgaGFzaCBwYXJhbWV0ZXJzXG4gICAgdXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBsZXQgX2ZldGNoO1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xufTtcbmV4cG9ydCBjb25zdCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlID0gKG1heWJlUmVzcG9uc2UpID0+IHtcbiAgICByZXR1cm4gKHR5cGVvZiBtYXliZVJlc3BvbnNlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBtYXliZVJlc3BvbnNlICE9PSBudWxsICYmXG4gICAgICAgICdzdGF0dXMnIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAgICAgJ29rJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgICdqc29uJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgIHR5cGVvZiBtYXliZVJlc3BvbnNlLmpzb24gPT09ICdmdW5jdGlvbicpO1xufTtcbi8vIFN0b3JhZ2UgaGVscGVyc1xuZXhwb3J0IGNvbnN0IHNldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXksIGRhdGEpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59O1xuZXhwb3J0IGNvbnN0IGdldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHJlbW92ZUl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbn07XG4vKipcbiAqIEEgZGVmZXJyZWQgcmVwcmVzZW50cyBzb21lIGFzeW5jaHJvbm91cyB3b3JrIHRoYXQgaXMgbm90IHlldCBmaW5pc2hlZCwgd2hpY2hcbiAqIG1heSBvciBtYXkgbm90IGN1bG1pbmF0ZSBpbiBhIHZhbHVlLlxuICogVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL21pa2Utbm9ydGgvdHlwZXMvYmxvYi9tYXN0ZXIvc3JjL2FzeW5jLnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgICA7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBEZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5EZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUpXVCh0b2tlbikge1xuICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZEp3dEVycm9yKCdJbnZhbGlkIEpXVCBzdHJ1Y3R1cmUnKTtcbiAgICB9XG4gICAgLy8gUmVnZXggY2hlY2tzIGZvciBiYXNlNjR1cmwgZm9ybWF0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIUJBU0U2NFVSTF9SRUdFWC50ZXN0KHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0pXVCBub3QgaW4gYmFzZTY0dXJsIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIC8vIHVzaW5nIGJhc2U2NHVybCBsaWJcbiAgICAgICAgaGVhZGVyOiBKU09OLnBhcnNlKHN0cmluZ0Zyb21CYXNlNjRVUkwocGFydHNbMF0pKSxcbiAgICAgICAgcGF5bG9hZDogSlNPTi5wYXJzZShzdHJpbmdGcm9tQmFzZTY0VVJMKHBhcnRzWzFdKSksXG4gICAgICAgIHNpZ25hdHVyZTogYmFzZTY0VXJsVG9VaW50OEFycmF5KHBhcnRzWzJdKSxcbiAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICBoZWFkZXI6IHBhcnRzWzBdLFxuICAgICAgICAgICAgcGF5bG9hZDogcGFydHNbMV0sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBudWxsIGFmdGVyIHNvbWUgdGltZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKGFjY2VwdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGFjY2VwdChudWxsKSwgdGltZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBhc3luYyBmdW5jdGlvbiBpbnRvIGEgcmV0cnlhYmxlIGZ1bmN0aW9uLiBFYWNoIHJlc3VsdFxuICogb3IgdGhyb3duIGVycm9yIGlzIHNlbnQgdG8gdGhlIGlzUmV0cnlhYmxlIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCByZXR1cm4gdHJ1ZVxuICogaWYgdGhlIGZ1bmN0aW9uIHNob3VsZCBydW4gYWdhaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyeWFibGUoZm4sIGlzUmV0cnlhYmxlKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBJbmZpbml0eTsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgbnVsbCwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGVjMmhleChkZWMpIHtcbiAgICByZXR1cm4gKCcwJyArIGRlYy50b1N0cmluZygxNikpLnN1YnN0cigtMik7XG59XG4vLyBGdW5jdGlvbnMgYmVsb3cgdGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjMzMDk0MDkvY3JlYXRpbmctYS1jb2RlLXZlcmlmaWVyLWFuZC1jaGFsbGVuZ2UtZm9yLXBrY2UtYXV0aC1vbi1zcG90aWZ5LWFwaS1pbi1yZWFjdGpzXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKSB7XG4gICAgY29uc3QgdmVyaWZpZXJMZW5ndGggPSA1NjtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSh2ZXJpZmllckxlbmd0aCk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktLl9+JztcbiAgICAgICAgY29uc3QgY2hhclNldExlbiA9IGNoYXJTZXQubGVuZ3RoO1xuICAgICAgICBsZXQgdmVyaWZpZXIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJpZmllckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJpZmllciArPSBjaGFyU2V0LmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyU2V0TGVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcmlmaWVyO1xuICAgIH1cbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgZGVjMmhleCkuam9pbignJyk7XG59XG5hc3luYyBmdW5jdGlvbiBzaGEyNTYocmFuZG9tU3RyaW5nKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWREYXRhID0gZW5jb2Rlci5lbmNvZGUocmFuZG9tU3RyaW5nKTtcbiAgICBjb25zdCBoYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBlbmNvZGVkRGF0YSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShieXRlcylcbiAgICAgICAgLm1hcCgoYykgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjKSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUEtDRUNoYWxsZW5nZSh2ZXJpZmllcikge1xuICAgIGNvbnN0IGhhc0NyeXB0b1N1cHBvcnQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJztcbiAgICBpZiAoIWhhc0NyeXB0b1N1cHBvcnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXZWJDcnlwdG8gQVBJIGlzIG5vdCBzdXBwb3J0ZWQuIENvZGUgY2hhbGxlbmdlIG1ldGhvZCB3aWxsIGRlZmF1bHQgdG8gdXNlIHBsYWluIGluc3RlYWQgb2Ygc2hhMjU2LicpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZXI7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGF3YWl0IHNoYTI1Nih2ZXJpZmllcik7XG4gICAgcmV0dXJuIGJ0b2EoaGFzaGVkKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89KyQvLCAnJyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChzdG9yYWdlLCBzdG9yYWdlS2V5LCBpc1Bhc3N3b3JkUmVjb3ZlcnkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IGdlbmVyYXRlUEtDRVZlcmlmaWVyKCk7XG4gICAgbGV0IHN0b3JlZENvZGVWZXJpZmllciA9IGNvZGVWZXJpZmllcjtcbiAgICBpZiAoaXNQYXNzd29yZFJlY292ZXJ5KSB7XG4gICAgICAgIHN0b3JlZENvZGVWZXJpZmllciArPSAnL1BBU1NXT1JEX1JFQ09WRVJZJztcbiAgICB9XG4gICAgYXdhaXQgc2V0SXRlbUFzeW5jKHN0b3JhZ2UsIGAke3N0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgLCBzdG9yZWRDb2RlVmVyaWZpZXIpO1xuICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2UgPSBhd2FpdCBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKTtcbiAgICBjb25zdCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gY29kZVZlcmlmaWVyID09PSBjb2RlQ2hhbGxlbmdlID8gJ3BsYWluJyA6ICdzMjU2JztcbiAgICByZXR1cm4gW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdO1xufVxuLyoqIFBhcnNlcyB0aGUgQVBJIHZlcnNpb24gd2hpY2ggaXMgMllZWS1NTS1ERC4gKi9cbmNvbnN0IEFQSV9WRVJTSU9OX1JFR0VYID0gL14yWzAtOV17M30tKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVswLTldfDJbMC05XXwzWzAtMV0pJC9pO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgYXBpVmVyc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FKTtcbiAgICBpZiAoIWFwaVZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghYXBpVmVyc2lvbi5tYXRjaChBUElfVkVSU0lPTl9SRUdFWCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHthcGlWZXJzaW9ufVQwMDowMDowMC4wWmApO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRXhwKGV4cCkge1xuICAgIGlmICghZXhwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBleHAgY2xhaW0nKTtcbiAgICB9XG4gICAgY29uc3QgdGltZU5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIGlmIChleHAgPD0gdGltZU5vdykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBoYXMgZXhwaXJlZCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGdvcml0aG0oYWxnKSB7XG4gICAgc3dpdGNoIChhbGcpIHtcbiAgICAgICAgY2FzZSAnUlMyNTYnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdFUzI1Nic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgICAgICAgICAgbmFtZWRDdXJ2ZTogJ1AtMjU2JyxcbiAgICAgICAgICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhbGcgY2xhaW0nKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJBUElfVkVSU0lPTl9IRUFERVJfTkFNRSIsIkJBU0U2NFVSTF9SRUdFWCIsIkF1dGhJbnZhbGlkSnd0RXJyb3IiLCJiYXNlNjRVcmxUb1VpbnQ4QXJyYXkiLCJzdHJpbmdGcm9tQmFzZTY0VVJMIiwiZXhwaXJlc0F0IiwiZXhwaXJlc0luIiwidGltZU5vdyIsIk1hdGgiLCJyb3VuZCIsIkRhdGUiLCJub3ciLCJ1dWlkIiwicmVwbGFjZSIsImMiLCJyIiwicmFuZG9tIiwidiIsInRvU3RyaW5nIiwiaXNCcm93c2VyIiwiZG9jdW1lbnQiLCJsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzIiwidGVzdGVkIiwid3JpdGFibGUiLCJzdXBwb3J0c0xvY2FsU3RvcmFnZSIsImdsb2JhbFRoaXMiLCJsb2NhbFN0b3JhZ2UiLCJlIiwicmFuZG9tS2V5Iiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJwYXJzZVBhcmFtZXRlcnNGcm9tVVJMIiwiaHJlZiIsInJlc3VsdCIsInVybCIsIlVSTCIsImhhc2giLCJoYXNoU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic3Vic3RyaW5nIiwiZm9yRWFjaCIsInZhbHVlIiwia2V5Iiwic2VhcmNoUGFyYW1zIiwicmVzb2x2ZUZldGNoIiwiY3VzdG9tRmV0Y2giLCJfZmV0Y2giLCJmZXRjaCIsImFyZ3MiLCJ0aGVuIiwiZGVmYXVsdCIsImxvb2tzTGlrZUZldGNoUmVzcG9uc2UiLCJtYXliZVJlc3BvbnNlIiwianNvbiIsInNldEl0ZW1Bc3luYyIsInN0b3JhZ2UiLCJkYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldEl0ZW1Bc3luYyIsImdldEl0ZW0iLCJwYXJzZSIsIl9hIiwicmVtb3ZlSXRlbUFzeW5jIiwiRGVmZXJyZWQiLCJjb25zdHJ1Y3RvciIsInByb21pc2UiLCJwcm9taXNlQ29uc3RydWN0b3IiLCJyZXMiLCJyZWoiLCJyZXNvbHZlIiwicmVqZWN0IiwiUHJvbWlzZSIsImRlY29kZUpXVCIsInRva2VuIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsImkiLCJ0ZXN0IiwiaGVhZGVyIiwicGF5bG9hZCIsInNpZ25hdHVyZSIsInJhdyIsInNsZWVwIiwidGltZSIsImFjY2VwdCIsInNldFRpbWVvdXQiLCJyZXRyeWFibGUiLCJmbiIsImlzUmV0cnlhYmxlIiwiYXR0ZW1wdCIsIkluZmluaXR5IiwiZGVjMmhleCIsImRlYyIsInN1YnN0ciIsImdlbmVyYXRlUEtDRVZlcmlmaWVyIiwidmVyaWZpZXJMZW5ndGgiLCJhcnJheSIsIlVpbnQzMkFycmF5IiwiY3J5cHRvIiwiY2hhclNldCIsImNoYXJTZXRMZW4iLCJ2ZXJpZmllciIsImNoYXJBdCIsImZsb29yIiwiZ2V0UmFuZG9tVmFsdWVzIiwiQXJyYXkiLCJmcm9tIiwiam9pbiIsInNoYTI1NiIsInJhbmRvbVN0cmluZyIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZWREYXRhIiwiZW5jb2RlIiwic3VidGxlIiwiZGlnZXN0IiwiYnl0ZXMiLCJVaW50OEFycmF5IiwibWFwIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlIiwiaGFzQ3J5cHRvU3VwcG9ydCIsImNvbnNvbGUiLCJ3YXJuIiwiaGFzaGVkIiwiYnRvYSIsImdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QiLCJzdG9yYWdlS2V5IiwiaXNQYXNzd29yZFJlY292ZXJ5IiwiY29kZVZlcmlmaWVyIiwic3RvcmVkQ29kZVZlcmlmaWVyIiwiY29kZUNoYWxsZW5nZSIsImNvZGVDaGFsbGVuZ2VNZXRob2QiLCJBUElfVkVSU0lPTl9SRUdFWCIsInBhcnNlUmVzcG9uc2VBUElWZXJzaW9uIiwicmVzcG9uc2UiLCJhcGlWZXJzaW9uIiwiaGVhZGVycyIsImdldCIsIm1hdGNoIiwiZGF0ZSIsInZhbGlkYXRlRXhwIiwiZXhwIiwiRXJyb3IiLCJnZXRBbGdvcml0aG0iLCJhbGciLCJuYW1lIiwibmFtZWRDdXJ2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/helpers.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/local-storage.js":
/*!****************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/local-storage.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   localStorageAdapter: () => (/* binding */ localStorageAdapter),\n/* harmony export */   memoryLocalStorageAdapter: () => (/* binding */ memoryLocalStorageAdapter)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * Provides safe access to the globalThis.localStorage property.\n */ const localStorageAdapter = {\n    getItem: (key)=>{\n        if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {\n            return null;\n        }\n        return globalThis.localStorage.getItem(key);\n    },\n    setItem: (key, value)=>{\n        if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {\n            return;\n        }\n        globalThis.localStorage.setItem(key, value);\n    },\n    removeItem: (key)=>{\n        if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {\n            return;\n        }\n        globalThis.localStorage.removeItem(key);\n    }\n};\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */ function memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key)=>{\n            return store[key] || null;\n        },\n        setItem: (key, value)=>{\n            store[key] = value;\n        },\n        removeItem: (key)=>{\n            delete store[key];\n        }\n    };\n} //# sourceMappingURL=local-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2FsLXN0b3JhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlEO0FBQ2pEOztDQUVDLEdBQ00sTUFBTUMsc0JBQXNCO0lBQy9CQyxTQUFTLENBQUNDO1FBQ04sSUFBSSxDQUFDSCw4REFBb0JBLElBQUk7WUFDekIsT0FBTztRQUNYO1FBQ0EsT0FBT0ksV0FBV0MsWUFBWSxDQUFDSCxPQUFPLENBQUNDO0lBQzNDO0lBQ0FHLFNBQVMsQ0FBQ0gsS0FBS0k7UUFDWCxJQUFJLENBQUNQLDhEQUFvQkEsSUFBSTtZQUN6QjtRQUNKO1FBQ0FJLFdBQVdDLFlBQVksQ0FBQ0MsT0FBTyxDQUFDSCxLQUFLSTtJQUN6QztJQUNBQyxZQUFZLENBQUNMO1FBQ1QsSUFBSSxDQUFDSCw4REFBb0JBLElBQUk7WUFDekI7UUFDSjtRQUNBSSxXQUFXQyxZQUFZLENBQUNHLFVBQVUsQ0FBQ0w7SUFDdkM7QUFDSixFQUFFO0FBQ0Y7OztDQUdDLEdBQ00sU0FBU00sMEJBQTBCQyxRQUFRLENBQUMsQ0FBQztJQUNoRCxPQUFPO1FBQ0hSLFNBQVMsQ0FBQ0M7WUFDTixPQUFPTyxLQUFLLENBQUNQLElBQUksSUFBSTtRQUN6QjtRQUNBRyxTQUFTLENBQUNILEtBQUtJO1lBQ1hHLEtBQUssQ0FBQ1AsSUFBSSxHQUFHSTtRQUNqQjtRQUNBQyxZQUFZLENBQUNMO1lBQ1QsT0FBT08sS0FBSyxDQUFDUCxJQUFJO1FBQ3JCO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2F1dGgtanNAMi42OS4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9jYWwtc3RvcmFnZS5qcz80MzhlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cHBvcnRzTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9oZWxwZXJzJztcbi8qKlxuICogUHJvdmlkZXMgc2FmZSBhY2Nlc3MgdG8gdGhlIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlIHByb3BlcnR5LlxuICovXG5leHBvcnQgY29uc3QgbG9jYWxTdG9yYWdlQWRhcHRlciA9IHtcbiAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9LFxuICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9LFxufTtcbi8qKlxuICogUmV0dXJucyBhIGxvY2FsU3RvcmFnZS1saWtlIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUga2V5LXZhbHVlIHBhaXJzIGluXG4gKiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHN0b3JlID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVba2V5XSB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWwtc3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOlsic3VwcG9ydHNMb2NhbFN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2VBZGFwdGVyIiwiZ2V0SXRlbSIsImtleSIsImdsb2JhbFRoaXMiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwidmFsdWUiLCJyZW1vdmVJdGVtIiwibWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciIsInN0b3JlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/locks.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/locks.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LockAcquireTimeoutError: () => (/* binding */ LockAcquireTimeoutError),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* binding */ NavigatorLockAcquireTimeoutError),\n/* harmony export */   ProcessLockAcquireTimeoutError: () => (/* binding */ ProcessLockAcquireTimeoutError),\n/* harmony export */   internals: () => (/* binding */ internals),\n/* harmony export */   navigatorLock: () => (/* binding */ navigatorLock),\n/* harmony export */   processLock: () => (/* binding */ processLock)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * @experimental\n */ const internals = {\n    /**\n     * @experimental\n     */ debug: !!(globalThis && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem(\"supabase.gotrue-js.locks.debug\") === \"true\")\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */ class LockAcquireTimeoutError extends Error {\n    constructor(message){\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */ async function navigatorLock(name, acquireTimeout, fn) {\n    if (internals.debug) {\n        console.log(\"@supabase/gotrue-js: navigatorLock: acquire lock\", name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(()=>{\n            abortController.abort();\n            if (internals.debug) {\n                console.log(\"@supabase/gotrue-js: navigatorLock acquire timed out\", name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(()=>globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n            mode: \"exclusive\",\n            ifAvailable: true\n        } : {\n            mode: \"exclusive\",\n            signal: abortController.signal\n        }, async (lock)=>{\n            if (lock) {\n                if (internals.debug) {\n                    console.log(\"@supabase/gotrue-js: navigatorLock: acquired\", name, lock.name);\n                }\n                try {\n                    return await fn();\n                } finally{\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: released\", name, lock.name);\n                    }\n                }\n            } else {\n                if (acquireTimeout === 0) {\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: not immediately available\", name);\n                    }\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n                } else {\n                    if (internals.debug) {\n                        try {\n                            const result = await globalThis.navigator.locks.query();\n                            console.log(\"@supabase/gotrue-js: Navigator LockManager state\", JSON.stringify(result, null, \"  \"));\n                        } catch (e) {\n                            console.warn(\"@supabase/gotrue-js: Error when querying Navigator LockManager state\", e);\n                        }\n                    }\n                    // Browser is not following the Navigator LockManager spec, it\n                    // returned a null lock when we didn't use ifAvailable. So we can\n                    // pretend the lock is acquired in the name of backward compatibility\n                    // and user experience and just run the function.\n                    console.warn(\"@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\");\n                    return await fn();\n                }\n            }\n        }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */ async function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(()=>{\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0 ? new Promise((_, reject)=>{\n            setTimeout(()=>{\n                reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n            }, acquireTimeout);\n        }) : null\n    ].filter((x)=>x)).catch((e)=>{\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    }).then(async ()=>{\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e)=>{\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n} //# sourceMappingURL=locks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2tzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUQ7QUFDakQ7O0NBRUMsR0FDTSxNQUFNQyxZQUFZO0lBQ3JCOztLQUVDLEdBQ0RDLE9BQU8sQ0FBQyxDQUFFQyxDQUFBQSxjQUNOSCw4REFBb0JBLE1BQ3BCRyxXQUFXQyxZQUFZLElBQ3ZCRCxXQUFXQyxZQUFZLENBQUNDLE9BQU8sQ0FBQyxzQ0FBc0MsTUFBSztBQUNuRixFQUFFO0FBQ0Y7Ozs7Q0FJQyxHQUNNLE1BQU1DLGdDQUFnQ0M7SUFDekNDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztJQUM1QjtBQUNKO0FBQ08sTUFBTUMseUNBQXlDTDtBQUN0RDtBQUNPLE1BQU1NLHVDQUF1Q047QUFDcEQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBQ00sZUFBZU8sY0FBY0MsSUFBSSxFQUFFQyxjQUFjLEVBQUVDLEVBQUU7SUFDeEQsSUFBSWYsVUFBVUMsS0FBSyxFQUFFO1FBQ2pCZSxRQUFRQyxHQUFHLENBQUMsb0RBQW9ESixNQUFNQztJQUMxRTtJQUNBLE1BQU1JLGtCQUFrQixJQUFJaEIsV0FBV2lCLGVBQWU7SUFDdEQsSUFBSUwsaUJBQWlCLEdBQUc7UUFDcEJNLFdBQVc7WUFDUEYsZ0JBQWdCRyxLQUFLO1lBQ3JCLElBQUlyQixVQUFVQyxLQUFLLEVBQUU7Z0JBQ2pCZSxRQUFRQyxHQUFHLENBQUMsd0RBQXdESjtZQUN4RTtRQUNKLEdBQUdDO0lBQ1A7SUFDQSxvRkFBb0Y7SUFDcEYsMEVBQTBFO0lBQzFFLHlFQUF5RTtJQUN6RSwwRUFBMEU7SUFDMUUsMkVBQTJFO0lBQzNFLDZFQUE2RTtJQUM3RSx3RUFBd0U7SUFD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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2tzLmpzPzJlNWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgfSBmcm9tICcuL2hlbHBlcnMnO1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGRlYnVnOiAhIShnbG9iYWxUaGlzICYmXG4gICAgICAgIHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkgJiZcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UgJiZcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnJykgPT09ICd0cnVlJyksXG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhIGxvY2sgY2Fubm90IGJlIGFjcXVpcmVkIGFmdGVyIHNvbWUgYW1vdW50IG9mIHRpbWUuXG4gKlxuICogVXNlIHRoZSB7QGxpbmsgI2lzQWNxdWlyZVRpbWVvdXR9IHByb3BlcnR5IGluc3RlYWQgb2YgY2hlY2tpbmcgd2l0aCBgaW5zdGFuY2VvZmAuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmlzQWNxdWlyZVRpbWVvdXQgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHtcbn1cbmV4cG9ydCBjbGFzcyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7XG59XG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdXNpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBBUEkuIEl0XG4gKiBpcyBhdmFpbGFibGUgb24gYWxsIGJyb3dzZXJzIHJlbGVhc2VkIGFmdGVyIDIwMjItMDMtMTUgd2l0aCBTYWZhcmkgYmVpbmcgdGhlXG4gKiBsYXN0IG9uZSB0byByZWxlYXNlIHN1cHBvcnQuIElmIHRoZSBBUEkgaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiB0aHJvdy4gTWFrZSBzdXJlIHlvdSBjaGVjayBhdmFpbGFibGlsaXR5IGJlZm9yZSBjb25maWd1cmluZyB7QGxpbmtcbiAqIEdvVHJ1ZUNsaWVudH0uXG4gKlxuICogWW91IGNhbiB0dXJuIG9uIGRlYnVnZ2luZyBieSBzZXR0aW5nIHRoZSBgc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnYFxuICogbG9jYWwgc3RvcmFnZSBpdGVtIHRvIGB0cnVlYC5cbiAqXG4gKiBJbnRlcm5hbHM6XG4gKlxuICogU2luY2UgdGhlIExvY2tNYW5hZ2VyIEFQSSBkb2VzIG5vdCBwcmVzZXJ2ZSBzdGFjayB0cmFjZXMgZm9yIHRoZSBhc3luY1xuICogZnVuY3Rpb24gcGFzc2VkIGluIHRoZSBgcmVxdWVzdGAgbWV0aG9kLCBhIHRyaWNrIGlzIHVzZWQgd2hlcmUgYWNxdWlyaW5nIHRoZVxuICogbG9jayByZWxlYXNlcyBhIHByZXZpb3VzbHkgc3RhcnRlZCBwcm9taXNlIHRvIHJ1biB0aGUgb3BlcmF0aW9uIGluIHRoZSBgZm5gXG4gKiBmdW5jdGlvbi4gVGhlIGxvY2sgd2FpdHMgZm9yIHRoYXQgcHJvbWlzZSB0byBmaW5pc2ggKHdpdGggb3Igd2l0aG91dCBlcnJvciksXG4gKiB3aGlsZSB0aGUgZnVuY3Rpb24gd2lsbCBmaW5hbGx5IHdhaXQgZm9yIHRoZSByZXN1bHQgYW55d2F5LlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRvckxvY2sobmFtZSwgYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZSBsb2NrJywgbmFtZSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2sgYWNxdWlyZSB0aW1lZCBvdXQnLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgIH1cbiAgICAvLyBNRE4gYXJ0aWNsZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3RcbiAgICAvLyBXcmFwcGluZyBuYXZpZ2F0b3IubG9ja3MucmVxdWVzdCgpIHdpdGggYSBwbGFpbiBQcm9taXNlIGlzIGRvbmUgYXMgc29tZVxuICAgIC8vIGxpYnJhcmllcyBsaWtlIHpvbmUuanMgcGF0Y2ggdGhlIFByb21pc2Ugb2JqZWN0IHRvIHRyYWNrIHRoZSBleGVjdXRpb25cbiAgICAvLyBjb250ZXh0LiBIb3dldmVyLCBpdCBhcHBlYXJzIHRoYXQgbW9zdCBicm93c2VycyB1c2UgYW4gaW50ZXJuYWwgcHJvbWlzZVxuICAgIC8vIGltcGxlbWVudGF0aW9uIHdoZW4gdXNpbmcgdGhlIG5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KCkgQVBJIGNhdXNpbmcgdGhlbVxuICAgIC8vIHRvIGxvc2UgY29udGV4dCBhbmQgZW1pdCBjb25mdXNpbmcgbG9nIG1lc3NhZ2VzIG9yIGJyZWFrIGNlcnRhaW4gZmVhdHVyZXMuXG4gICAgLy8gVGhpcyB3cmFwcGluZyBpcyBiZWxpZXZlZCB0byBoZWxwIHpvbmUuanMgdHJhY2sgdGhlIGV4ZWN1dGlvbiBjb250ZXh0XG4gICAgLy8gYmV0dGVyLlxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QobmFtZSwgYWNxdWlyZVRpbWVvdXQgPT09IDBcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIGlmQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgbW9kZTogJ2V4Y2x1c2l2ZScsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIH0sIGFzeW5jIChsb2NrKSA9PiB7XG4gICAgICAgIGlmIChsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IGFjcXVpcmVkJywgbmFtZSwgbG9jay5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiByZWxlYXNlZCcsIG5hbWUsIGxvY2submFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFjcXVpcmVUaW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogbm90IGltbWVkaWF0ZWx5IGF2YWlsYWJsZScsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoYEFjcXVpcmluZyBhbiBleGNsdXNpdmUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIGxvY2sgXCIke25hbWV9XCIgaW1tZWRpYXRlbHkgZmFpbGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnbG9iYWxUaGlzLm5hdmlnYXRvci5sb2Nrcy5xdWVyeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IE5hdmlnYXRvciBMb2NrTWFuYWdlciBzdGF0ZScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgJyAgJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IEVycm9yIHdoZW4gcXVlcnlpbmcgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQnJvd3NlciBpcyBub3QgZm9sbG93aW5nIHRoZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3BlYywgaXRcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5lZCBhIG51bGwgbG9jayB3aGVuIHdlIGRpZG4ndCB1c2UgaWZBdmFpbGFibGUuIFNvIHdlIGNhblxuICAgICAgICAgICAgICAgIC8vIHByZXRlbmQgdGhlIGxvY2sgaXMgYWNxdWlyZWQgaW4gdGhlIG5hbWUgb2YgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIC8vIGFuZCB1c2VyIGV4cGVyaWVuY2UgYW5kIGp1c3QgcnVuIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IE5hdmlnYXRvciBMb2NrTWFuYWdlciByZXR1cm5lZCBhIG51bGwgbG9jayB3aGVuIHVzaW5nICNyZXF1ZXN0IHdpdGhvdXQgaWZBdmFpbGFibGUgc2V0IHRvIHRydWUsIGl0IGFwcGVhcnMgdGhpcyBicm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIExvY2tNYW5hZ2VyIHNwZWMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKTtcbn1cbmNvbnN0IFBST0NFU1NfTE9DS1MgPSB7fTtcbi8qKlxuICogSW1wbGVtZW50cyBhIGdsb2JhbCBleGNsdXNpdmUgbG9jayB0aGF0IHdvcmtzIG9ubHkgaW4gdGhlIGN1cnJlbnQgcHJvY2Vzcy5cbiAqIFVzZWZ1bCBmb3IgZW52aXJvbm1lbnRzIGxpa2UgUmVhY3QgTmF0aXZlIG9yIG90aGVyIG5vbi1icm93c2VyXG4gKiBzaW5nbGUtcHJvY2VzcyAoaS5lLiBubyBjb25jZXB0IG9mIFwidGFic1wiKSBlbnZpcm9ubWVudHMuXG4gKlxuICogVXNlIHtAbGluayAjbmF2aWdhdG9yTG9ja30gaW4gYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dC4gSWYgMCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgbG9jayBjYW4ndCBiZSBhY3F1aXJlZCB3aXRob3V0IHdhaXRpbmcuIElmIHBvc2l0aXZlLCB0aGUgbG9jayBhY3F1aXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCB0aW1lIG91dCBhZnRlciBzbyBtYW55IG1pbGxpc2Vjb25kcy4gQW4gZXJyb3IgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICBhIHRpbWVvdXQgaWYgaXQgaGFzIGBpc0FjcXVpcmVUaW1lb3V0YCBzZXQgdG8gdHJ1ZS5cbiAqIEBwYXJhbSBmbiBUaGUgb3BlcmF0aW9uIHRvIHJ1biBvbmNlIHRoZSBsb2NrIGlzIGFjcXVpcmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0xvY2sobmFtZSwgYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByZXZpb3VzT3BlcmF0aW9uID0gKF9hID0gUFJPQ0VTU19MT0NLU1tuYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3QgY3VycmVudE9wZXJhdGlvbiA9IFByb21pc2UucmFjZShbXG4gICAgICAgIHByZXZpb3VzT3BlcmF0aW9uLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvciBvZiBwcmV2aW91cyBvcGVyYXRpb24gdGhhdCB3ZSdyZSB3YWl0aW5nIHRvIGZpbmlzaFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pLFxuICAgICAgICBhY3F1aXJlVGltZW91dCA+PSAwXG4gICAgICAgICAgICA/IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoYEFjcXVyaW5nIHByb2Nlc3MgbG9jayB3aXRoIG5hbWUgXCIke25hbWV9XCIgdGltZWQgb3V0YCkpO1xuICAgICAgICAgICAgICAgIH0sIGFjcXVpcmVUaW1lb3V0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgXS5maWx0ZXIoKHgpID0+IHgpKVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pXG4gICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gcHJldmlvdXMgb3BlcmF0aW9ucyBmaW5pc2hlZCBhbmQgd2UgZGlkbid0IGdldCBhIHJhY2Ugb24gdGhlIGFjcXVpcmVcbiAgICAgICAgLy8gdGltZW91dCwgc28gdGhlIGN1cnJlbnQgb3BlcmF0aW9uIGNhbiBmaW5hbGx5IHN0YXJ0XG4gICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgIH0pO1xuICAgIFBST0NFU1NfTE9DS1NbbmFtZV0gPSBjdXJyZW50T3BlcmF0aW9uLmNhdGNoKGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGlmIChlICYmIGUuaXNBY3F1aXJlVGltZW91dCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIHRpbWVkIG91dCwgaXQgZG9lc24ndCBtZWFuIHRoYXQgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAvLyBvcGVyYXRpb24gZmluaXNoZWQsIHNvIHdlIG5lZWQgY29udG51ZSB3YWl0aW5nIGZvciBpdCB0byBmaW5pc2hcbiAgICAgICAgICAgIGF3YWl0IHByZXZpb3VzT3BlcmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgICAvLyBmaW5hbGx5IHdhaXQgZm9yIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0byBmaW5pc2ggc3VjY2Vzc2Z1bGx5LCB3aXRoIGFuXG4gICAgLy8gZXJyb3Igb3Igd2l0aCBhbiBhY3F1aXJlIHRpbWVvdXQgZXJyb3JcbiAgICByZXR1cm4gYXdhaXQgY3VycmVudE9wZXJhdGlvbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2tzLmpzLm1hcCJdLCJuYW1lcyI6WyJzdXBwb3J0c0xvY2FsU3RvcmFnZSIsImludGVybmFscyIsImRlYnVnIiwiZ2xvYmFsVGhpcyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiaXNBY3F1aXJlVGltZW91dCIsIk5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIiwiUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yIiwibmF2aWdhdG9yTG9jayIsIm5hbWUiLCJhY3F1aXJlVGltZW91dCIsImZuIiwiY29uc29sZSIsImxvZyIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInNldFRpbWVvdXQiLCJhYm9ydCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIm5hdmlnYXRvciIsImxvY2tzIiwicmVxdWVzdCIsIm1vZGUiLCJpZkF2YWlsYWJsZSIsInNpZ25hbCIsImxvY2siLCJyZXN1bHQiLCJxdWVyeSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwid2FybiIsIlBST0NFU1NfTE9DS1MiLCJwcm9jZXNzTG9jayIsIl9hIiwicHJldmlvdXNPcGVyYXRpb24iLCJjdXJyZW50T3BlcmF0aW9uIiwicmFjZSIsImNhdGNoIiwiXyIsInJlamVjdCIsImZpbHRlciIsIngiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/locks.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/polyfills.js":
/*!************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/polyfills.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyfillGlobalThis: () => (/* binding */ polyfillGlobalThis)\n/* harmony export */ });\n/**\n * https://mathiasbynens.be/notes/globalthis\n */ function polyfillGlobalThis() {\n    if (typeof globalThis === \"object\") return;\n    try {\n        Object.defineProperty(Object.prototype, \"__magic__\", {\n            get: function() {\n                return this;\n            },\n            configurable: true\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    } catch (e) {\n        if (typeof self !== \"undefined\") {\n            // @ts-expect-error 'Allow access to globals'\n            self.globalThis = self;\n        }\n    }\n} //# sourceMappingURL=polyfills.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3BvbHlmaWxscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FDTSxTQUFTQTtJQUNaLElBQUksT0FBT0MsZUFBZSxVQUN0QjtJQUNKLElBQUk7UUFDQUMsT0FBT0MsY0FBYyxDQUFDRCxPQUFPRSxTQUFTLEVBQUUsYUFBYTtZQUNqREMsS0FBSztnQkFDRCxPQUFPLElBQUk7WUFDZjtZQUNBQyxjQUFjO1FBQ2xCO1FBQ0EsMkNBQTJDO1FBQzNDQyxVQUFVTixVQUFVLEdBQUdNO1FBQ3ZCLDJDQUEyQztRQUMzQyxPQUFPTCxPQUFPRSxTQUFTLENBQUNHLFNBQVM7SUFDckMsRUFDQSxPQUFPQyxHQUFHO1FBQ04sSUFBSSxPQUFPQyxTQUFTLGFBQWE7WUFDN0IsNkNBQTZDO1lBQzdDQSxLQUFLUixVQUFVLEdBQUdRO1FBQ3RCO0lBQ0o7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2F1dGgtanNAMi42OS4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvcG9seWZpbGxzLmpzP2U1ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcG9seWZpbGxHbG9iYWxUaGlzKCkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ19fbWFnaWNfXycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICAgICAgX19tYWdpY19fLmdsb2JhbFRoaXMgPSBfX21hZ2ljX187XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICAgICAgZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19tYWdpY19fO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gZ2xvYmFscydcbiAgICAgICAgICAgIHNlbGYuZ2xvYmFsVGhpcyA9IHNlbGY7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5ZmlsbHMuanMubWFwIl0sIm5hbWVzIjpbInBvbHlmaWxsR2xvYmFsVGhpcyIsImdsb2JhbFRoaXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsImdldCIsImNvbmZpZ3VyYWJsZSIsIl9fbWFnaWNfXyIsImUiLCJzZWxmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/types.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/types.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7QUFBVSxDQUNWLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2F1dGgtanNAMi42OS4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdHlwZXMuanM/OTU1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/types.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/version.js":
/*!**********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/version.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"2.69.1\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZSthdXRoLWpzQDIuNjkuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanM/N2E2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjY5LjEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/.pnpm/@supabase+auth-js@2.69.1/node_modules/@supabase/auth-js/dist/module/lib/version.js\n");

/***/ })

};
;